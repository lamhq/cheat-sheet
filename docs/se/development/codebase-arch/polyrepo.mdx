# Polyrepo

## Overview

Each project / service / component has its own repository.

Each repo often has a single build artifact, and simple build pipeline.

Suitable for projects where each component or service is independent or loosely coupled.

![](https://monorepo.tools/images/polyrepo-practice.svg)


## Use cases

- **Distinct Teams and Ownership**: When different teams own and manage distinct projects, a multirepo provides clear ownership and autonomy.
- **Diverse technology stacks**: It allows teams to use the best tools and languages for their specific projects without being restricted to a single, company-wide stack.
- **Independent release cycles**: Teams can release their projects on their own schedule without having to coordinate with other teams.
- **Granular Security and Access Control**: Access to each project must be controlled individually, ensuring that developers only have access to the repository they need.


## Benefits

- **Autonomous Teams**. Each team can work independently with different libraries and release cycles.
- **Isolation of Projects**. Easier to manage dependencies and avoid unintended side effects.
- **Security**. You can restrict access to sensitive repositories without exposing the entire codebase.


## Challenges

- **Costly cross-repo changes**. Changes across repos can't be atomic, requiring multiple commits per repository. Plus difficulty in coordinating changes across repositories.
- **Introducing potential bugs**. Some bugs can only occur at the point of integration rather than when code is changed.
- **Cumbersome code sharing**. Require setting up a separated repository for the shared code: tooling, build pipeline, committers, package publishing. Increases the burden of maintenance, security, and quality control.
- **Inconsistent tooling and standards**: Teams may adopt different tools (scripts, test, build, lint, deploy) and conventions that makes development experience varies too greatly.
- **Overhead when maintaining multiple repositories**. Requires maintaining awareness of all repositories and their respective functions.
- **Onboarding complexity**: Assigning new team members to the correct repositories may take additional time and effort.
