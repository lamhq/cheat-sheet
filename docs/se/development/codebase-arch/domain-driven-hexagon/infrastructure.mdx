# Infrastructure

## Introduction

The Infrastructure layer provides the technical capabilities needed to support the application and domain.

Depends on the Core layer. Provides concrete adapters (e.g., database repositories, message brokers, external APIs) that implement ports defined in the Application Layer.

Handles data persistence, networking, logging, caching, authentication, integration with external systems.

It's the most volatile layer. It's kept separate in order to make it easy to make changes or swap one component for another.

Can contain:
- framework related code
- I/O services that access external resources
- database repositories
- ORM entities/Schemas
- messages/events publishers
- email services
- file storage services
- etc.

Example:
1. The Application Layer defines an `OrderRepositoryPort`.
2. The Infrastructure Layer provides `PostgresOrderRepository` or `MongoOrderRepository` that implements this port.
3. At runtime, a DI library injects the chosen implementation into the Application Service.  


## Adapters

Infrastructure adapters enable interaction with external systems (databases, message brokers, 3rd party APIs, etc.).

Adapters also can be used to interact with different domains inside single process to avoid coupling between those domains.

Adapters implement ports and should only be accessed through them. Callers depend on ports, not adapter implementations.

Key components of adapters:
- A port in the domain layer they implement.
- A mapper that maps data from and to domain (if needed).
- A DTO/interface for received data.
- A validator to ensure data integrity (via decorators in DTO class or Value Objects).


## Repositories

Repositories abstract collections of entities in a database. They centralize data access and encapsulate logic for accessing data.

They are used to decouple database technology from the domain model layer.

Data flow:
1. Receive a domain Entity from the application service.
2. Map it to a database schema/ORM format.
3. Perform operations (save, update, retrieve, etc.).
4. Map it back to a domain Entity and return it.

Example code:
- [repository.port.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/libs/ddd/repository.port.ts) - defines the generic port that repositories should implement
- [sql-repository.base.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/libs/db/sql-repository.base.ts) - abstract repository class that allows to make basic CRUD operations
- [user.repository.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/database/user.repository.ts) - concrete repository that extends `SqlRepositoryBase` and implements `RepositoryPort`

> [!NOTE]
> The application's core usually depends on abstractions (ports/interfaces), not repositories. However, this abstraction may be unnecessary for projects unlikely to change database technology. It can also limit the use of database-specific features.


## Persistence models

In DDD, domain models and persistence models should be separate to avoid a database-centric architecture. Domain models focus on logic, while persistence models suit database needs.

Benefits:
- Avoids mixing domain logic with database concerns.
- Allows database normalization or denormalization as needed.

Challenges:
- Requires effort to create and maintain mappers and abstractions.
- May be overkill for smaller applications.

Example code:
- [`user.repository.ts`](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/database/user.repository.ts): Defines `userSchema` and `UserModel` for database representation.
- [`user.mapper.ts`](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/user.mapper.ts): Maps between domain and persistence models.

> [!TIP]
> For smaller projects, consider using ORM libraries like TypeORM for simplicity.