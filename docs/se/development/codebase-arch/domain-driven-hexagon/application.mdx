# Application Layer

## Application Services

Application Services are used to orchestrate the steps required to fulfill the commands imposed by the client.

Application services:
- Typically orchestrate how the outside world interacts with your application and perform tasks required by end users.
- Contain no domain-specific business logic.
- Operate on scalar types, transforming them into Domain types. A scalar type includes primitive types and types that don't belong to the Domain.
- Use **ports** (interfaces) to declare dependencies on infrastructural services/adapters required to execute domain logic.
- Fetch domain `Entities`/`Aggregates` (or other objects) from databases/external APIs (through ports/interfaces, with concrete implementations injected by the [DI](https://en.wikipedia.org/wiki/Dependency_injection) library).
- Execute domain logic on `Entities`/`Aggregates` (by invoking their methods).
- When working with multiple `Entities`/`Aggregates`, use a `Domain Service` to orchestrate them.
- Execute other out-of-process communications through Ports (e.g., event emission, sending emails).
- Can be used as `Command`/`Query` handlers.
- Should not depend on other application services, as this may cause problems (such as cyclic dependencies).

One service per **use case** is considered good practice.

> [!INFO]  
> A use case is a list of actions/steps defining the interactions between an actor (UML) and a system to achieve a goal.

Example code:
- [`create-user.service.ts`](https://github.com/Sairyss/domain-driven-hexagon/blob/master/https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.service.ts)


## Commands and Queries

Methods should be separated into Commands (state-changing operations) and Queries (data-retrieval operations).

Before a DTO reaches the domain, it's converted into a Command/Query object.

By enforcing `Command` and `Query` separation, the code becomes simpler to understand. One changes something, another just retrieves data.

Following CQS from the start will facilitate separating write and read models into different databases if someday in the future the need for it arises.


### Command

A `Command` is an object that signals user intent, for example `CreateUserCommand`. It describes a single action (but does not perform it).

`Commands` are used for state-changing actions, such as creating a new user and saving it to the database. Create, Update, and Delete operations are considered state-changing.

`Command` methods can return the ID of a created item, a redirect link, a confirmation message, a status, or other metadata.

You use a `Command Bus` to execute a command instead of importing a service directly. This decouples a command Invoker from a Receiver, so you can send your commands from anywhere without creating coupling.

Avoid command handlers executing other commands (Command → Command). Instead, use events for that purpose, and execute subsequent commands in a chain within an Event handler (Command → Event → Command).

Example code:
- [create-user.command.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.command.ts) – a command object.
- [create-user.message.controller.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.message.controller.ts) – controller executes a command using a command bus. This decouples it from a command handler.
- [create-user.service.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.service.ts) – a command handler.


### Queries

`Query` is similar to a `Command`. It belongs to a read model and signals user intent to find something and describes how to do it.

`Query` is just a data retrieval operation and should not make any state changes (like writes to the database, files, third party APIs, etc.). For this reason, in read model we can bypass a domain and repository layers completely and query database directly from a query handler.

You use a `Query Bus` to execute a query without importing classes directly and avoid coupling.

Example code:
- [find-users.query-handler.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/queries/find-users/find-users.query-handler.ts) - a query handler. Notice how we query the database directly, without using domain objects or repositories (more info [here](https://codeopinion.com/should-you-use-the-repository-pattern-with-cqrs-yes-and-no/)).

> [!NOTE]
> This guide uses [NestJS CQRS](https://docs.nestjs.com/recipes/cqrs) package that provides a command/query bus.


## Ports

Ports are interfaces that define contracts that should be implemented by adapters.

Ports can be created to abstract side effects like I/O operations and database access, technology details, invasive libraries, legacy code etc. from the Domain.

Ports should be created to fit the Domain needs, not simply mimic the tools APIs.

Any external calls to extenal systems or remote processes should be done through ports (interfaces), implementations is created somewhere in infrastructure layer and injected into application's core through [DI](https://en.wikipedia.org/wiki/Dependency_injection). This makes business logic independent of technology, facilitates testing, allows to plug/unplug/swap any external resources easily making application modular and loosely coupled.

When designing ports, split large interfaces into smaller ones when it makes sense, but also keep in mind to not overdo it when not necessary ([Interface segregation principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)).

To avoid [unnecessary abstractions](https://mortoray.com/2014/08/01/the-false-abstraction-antipattern/) and overcomplicate your application, only use ports for things might change in the future (database, external APIs, frameworks etc.).

Example code:
- [repository.port.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/libs/ddd/repository.port.ts) - generic port for repositories
- [user.repository.port.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/database/user.repository.port.ts) - a port for user repository
- [find-users.query-handler.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/queries/find-users/find-users.query-handler.ts) - notice how query handler depends on a port instead of concrete repository implementation, and an implementation is injected
- [logger.port.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/libs/ports/logger.port.ts) - another example of a port for application logger

Benefits:
- You can test your application logic in isolation by mocking the implementation.
- Abstraction provided by ports can be used to inject different implementations to a port if needed
- Ports can also help to delay decisions. The Domain layer can be implemented even before deciding what technologies (frameworks, databases etc.) will be used.
