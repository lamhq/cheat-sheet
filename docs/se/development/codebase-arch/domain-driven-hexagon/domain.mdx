# Domain Layer

This layer contains the application's business rules.

Domain should operate using domain objects described by [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html).

Most important domain building blocks are described below:


## Entities

Entities encapsulate enterprise-wide business rules and attributes. An entity can be an object with properties and methods, or it can be a set of data structures and functions.

Entities express what properties a particular model has, what it can do, when and at what conditions it can do it.

Examples: User, Product, Booking, Ticket, Wallet etc.

Avoid having business logic in your services when possible, this leads to [Anemic Domain Model](https://martinfowler.com/bliki/AnemicDomainModel.html) (Domain Services are an exception for business logic that can't be put in a single entity).

Equality between two entities is determined by comparing their identificators (usually its `id` field).

Entities can contain other objects, such as other entities or value objects.

Entities should always be valid. Validate Entities and other domain objects on creation and throw an error on first failure. *For example, an order item object always has to have a quantity that must be a positive integer, plus an article name and price*.

Entities must protect their **invariants**, try to avoid public setters - update state using methods and execute invariant validation on each update if needed (this can be a simple `validate()` method that checks if business rules are not violated by update).

When creating entities, avoid no-arg (empty) constructors, accept and validate all required properties in a constructor (or in a [factory method](https://en.wikipedia.org/wiki/Factory_method_pattern) like `create()`).

Make Entities partially immutable. Identify what properties shouldn't change after creation and make them readonly (for example `id` or `createdAt`).

> [!CAUTION]
> It's not recommended to create one module per entity. Each module may have multiple entities, and those entities need to have related business logic, don't group unrelated entities in one module.

Example code:
- [user.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/user.entity.ts)
- [wallet.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/wallet/domain/wallet.entity.ts)


## Aggregates

**Aggregate** is a cluster of domain objects, it encapsulates entities and value objects which conceptually belong together. It also contains a set of operations which those domain objects can be operated on.

Aggregates help to simplify the domain model by gathering multiple domain objects under a single abstraction.

Aggregates should not be influenced by the data model. Associations between domain objects are not the same as database relationships.

**Aggregate root** is an entity that contains other entities/value objects and all logic to operate them.

Aggregate root has global identity (UUID / GUID / primary key). Entities inside the aggregate boundary have local identities, unique only within the Aggregate.

Aggregate root is a gateway to entire aggregate. Any references from outside the aggregate should only go to the aggregate root.

Any operations on an aggregate must be [transactional operations](https://en.wikipedia.org/wiki/Database_transaction). Either everything gets saved/updated/deleted or nothing.

Only Aggregate Roots can be obtained directly with database queries. Everything else must be done through traversal.

Similar to Entities, aggregates must protect their **invariants** through entire lifecycle. When a change to any object within the Aggregate boundary is committed, all **invariants** of the whole Aggregate must be satisfied. If one object inside an aggregate changes state, this shouldn't conflict with other domain objects inside this aggregate (this is called Consistency Boundary).

Objects within the Aggregate can reference other Aggregate roots via their globally unique identifier (id). Avoid holding a direct object reference.

Try to avoid aggregates that are too big, this can lead to performance and maintaining problems.

In summary, if you combine multiple related entities and value objects inside one root Entity, this root Entity becomes an **Aggregate Root**, and this cluster of related entities and value objects becomes an **Aggregate**.

Example code:
- [aggregate-root.base.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/libs/ddd/aggregate-root.base.ts) - abstract base class.
- [user.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/user.entity.ts) - aggregates are just entities that have to follow a set of specific rules described above.


## Domain Events

Domain Event indicates that something happened in a domain that you want other parts of the same domain (**in the same process**) to be aware of.

Domain events are just messages pushed to an in-memory Domain Event dispatcher.

For example, if a user buys something, you may want to:
- Update his shopping cart;
- Withdraw money from his wallet;
- Create a new shipping order;
- Perform other domain operations that are not a concern of an aggregate that executes a "buy" command.

If executing a command requires additional domain rules to be run on one or more additional aggregates, you can design and implement those side effects to be triggered by Domain Events. Propagation of state changes across multiple aggregates within the same domain model can be performed by subscribing to a concrete Domain Event and creating as many event handlers as needed. 

Domain Events may be useful for creating an audit log to track all changes to important entities by saving each event to the database.

All changes caused by Domain Events across multiple aggregates in a single process can be saved in a single database transaction. 

Example code:

- [user-created.domain-event.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/events/user-created.domain-event.ts) - simple object that holds data related to published event.
- [create-wallet-when-user-is-created.domain-event-handler.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/wallet/application/event-handlers/create-wallet-when-user-is-created.domain-event-handler.ts) - this is an example of Domain Event Handler that executes some actions when a domain event is raised (in this case, when user is created it also creates a wallet for that user).
- [sql-repository.base.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/libs/db/sql-repository.base.ts) - repository publishes all domain events for execution when it persists changes to an aggregate.
- [create-user.service.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.service.ts) - in a service we execute a global transaction to make sure all the changes done by Domain Events across the application are stored atomically (all or nothing).


## Integration Events

Integration Events are events sent to external process (microservices, external APIs).

Integration Events usually should be published only after all Domain Events finished executing and saving all changes to the database.

To handle integration events you may need an external message broker / event bus like RabbitMQ or Kafka together with patterns like Transactional outbox, Change Data Capture, Sagas or a Process Manager to maintain eventual consistency.


## Domain Services

Domain Service is a specific type of domain layer class that is used to execute domain logic that relies on two or more **Entities**.

Domain Services are used when putting the logic on a particular Entity would break encapsulation and require the **Entity** to know about things it really shouldn't be concerned with.

Domain services operate only on types belonging to the Domain. They contain meaningful concepts that can be found within the Ubiquitous Language. They hold operations that don't fit well into **Value Objects** or **Entities**.


## Value objects

Some Attributes and behaviors can be moved out of the entity itself and put into Value Objects.

Value Objects:

- Have no identity. Equality is determined through structural property.
- Are immutable.
- Can be used as an attribute of entities and other value objects.
- Explicitly defines and enforces important constraints (invariants).

Value object shouldn’t be just a convenient grouping of attributes but should form a well-defined concept in the domain model. This is true even if it contains only one attribute.

For example, imagine you have a **User** entity which needs to have an **address** of a user. Usually an address is simply a complex value that has no identity in the domain and is composed of multiple other values, like country, street, postalCode etc., so it can be modeled and treated as a **Value Object** with its own business logic.

**Value object** isn’t just a data structure that holds values. It can also encapsulate logic associated with the concept it represents.

Example code:
- [address.value-object.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/value-objects/address.value-object.ts)


## Domain Invariants

Domain [invariants](https://en.wikipedia.org/wiki/Invariant_(mathematics)#Invariants_in_computer_science) are the policies and conditions that are always met for the Domain in particular context. Invariants determine what is possible or what is prohibited in the context.

For example:

- When sending money, amount must always be a positive integer, and there always must be a receiver credit card number in a correct format;
- Client cannot purchase a product that is out of stock;
- Client's wallet cannot have less than 0 balance;

Domain objects (especially of the entities and aggregate roots) are responsible for enforcing invariants. They should not be able to exist without following business rules.

Example code:
- [wallet.entity.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/wallet/domain/wallet.entity.ts) (notice `validate` method. This is a simplified example of enforcing a domain invariant).


## Domain Errors
