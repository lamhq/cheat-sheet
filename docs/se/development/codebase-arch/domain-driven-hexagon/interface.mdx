# Interface Adapters

## Introduction

Also known as **Driving/Primary Adapters**.

This layer serves as the app's entry point.

It provides user-facing interfaces like:
- Input/Output (request/response) DTOs
- CLI Controllers
- Event Handlers

It wraps the application core, adapting its input/output to delivery mechanisms (e.g., HTML, JSON, CLI, gRPC).

It depends on the **Core** layer, communicating with it via **Commands**/**Queries** handled by **Application Services**. 

Interface adapters:
- Transform client input in a form that is convenient for **use cases** and **entities**.
- Transform output from use cases and entities for client to display.


## Controllers

Controllers are user-facing APIs that parse requests, trigger business logic, and present results to clients.

Best Practices:
- Use one controller per **use case** for clarity.
- Separate controllers by trigger type, e.g.,:
  - HTTP requests: [create-user.http.controller.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.http.controller.ts)
  - CLI access: [create-user.cli.controller.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.cli.controller.ts)
  - External messages: [create-user.message.controller.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.message.controller.ts)


## Resolvers

If you are using GraphQL instead of controllers, you will use Resolvers.

Example code:

- [create-user.graphql-resolver.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/graphql-example/create-user.graphql-resolver.ts)


## DTOs

Data Transfer Objects (DTOs) carry data between processes and define contracts between APIs and clients.

### Request and Response DTOs
- **Request DTOs**: Define the structure clients must follow to make valid requests. Example: [create-user.request.dto.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.request.dto.ts)
- **Response DTOs**: Ensure clients receive only the intended data, preventing data leaks. Example: [create-user.response.dto.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/dtos/user.response.dto.ts)

### Benefits
- Protect clients from internal data structure changes.
- Maintain compatibility by mapping internal changes to DTOs.

> [!NOTE]
> Command objects may have similar structure to Request DTOs but serve internal domain communication, not client contracts.

**Best Practices**:
- DTOs's properties should be mostly primitives, flat structures.
- When returning responses, prefer whitelisting (only allow predefined properties) over blacklisting (excluding certain properties) for security.
- Place DTOs in a shared package if used across apps (e.g., frontend, backend) via .
- Use validation/sanitization decorators like [class-validator](https://www.npmjs.com/package/class-validator) and [class-sanitizer](https://www.npmjs.com/package/class-sanitizer) for DTOs.
- Transform data to DTOs using separated mappers or perform transformation in DTO constructors.

### Local DTOs

Local DTOs are used as contracts between the domain and other layers when you don't want to expose your domain objects (entities, .etc) outside of the domain layer.

Local DTOs can be used to:
- Prevent exposing domain objects outside the domain layer. They're contracts between the domain and other layers.
- Decouple modules by avoiding leaking entities between them.

Downsides of Local DTOs: adds complexity and requires extra boilerplate (e.g., defining interfaces, data mapping).