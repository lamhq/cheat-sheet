# Domain

Holds the pure business logic. Defines the rules, invariants, and behaviors of the system.

Completely independent of frameworks, databases, or external technologies.

Remains the most stable part of the architecture.

Domain should operate using domain objects described by [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html).

Contains:
- **Entities**: contain domain business logic and attributes and has an identity (id).
- **Aggregates**: similar to entities, but encapsulate a cluster of domain objects.
- **Value Objects**: wrap one or multiple attributes and the logic associated with those attributes; has no identity.
- **Domain Services**: orchestrates domain logic between multiple Entities.
- **Domain Events**: Capture and broadcast significant changes in the domain.
- **Domain Errors**: Explicit error handling using result objects instead of exceptions.


## Entities

Entities encapsulate enterprise-wide business rules and attributes. An entity can be an object with properties and methods, or it can be a set of data structures and functions.

Entities express what properties a particular model has, what it can do, when and at what conditions it can do it.

Examples: User, Product, Booking, Ticket, Wallet etc.

Avoid having business logic in your services when possible, this leads to [Anemic Domain Model](https://martinfowler.com/bliki/AnemicDomainModel.html) (Domain Services are an exception for business logic that can't be put in a single entity).

Equality between two entities is determined by comparing their identificators (usually its `id` field).

Entities can contain other objects, such as other entities or value objects.

Entities should always be valid. Validate Entities and other domain objects on creation and throw an error on first failure. *For example, an order item object always has to have a quantity that must be a positive integer, plus an article name and price*.

Entities must protect their **invariants**, try to avoid public setters - update state using methods and execute invariant validation on each update if needed (this can be a simple `validate()` method that checks if business rules are not violated by update).

When creating entities, avoid no-arg (empty) constructors, accept and validate all required properties in a constructor (or in a [factory method](https://en.wikipedia.org/wiki/Factory_method_pattern) like `create()`).

Make Entities partially immutable. Identify what properties shouldn't change after creation and make them readonly (for example `id` or `createdAt`).

> [!CAUTION]
> It's not recommended to create one module per entity. Each module may have multiple entities, and those entities need to have related business logic, don't group unrelated entities in one module.

Example code:
- [user.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/user.entity.ts)
- [wallet.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/wallet/domain/wallet.entity.ts)


## Aggregates

**Aggregate** is a cluster of domain objects, it encapsulates entities and value objects which conceptually belong together. It also contains a set of operations which those domain objects can be operated on.

Aggregates help to simplify the domain model by gathering multiple domain objects under a single abstraction.

Aggregates should not be influenced by the data model. Associations between domain objects are not the same as database relationships.

**Aggregate root** is an entity that contains other entities/value objects and all logic to operate them.

Aggregate root has global identity (UUID / GUID / primary key). Entities inside the aggregate boundary have local identities, unique only within the Aggregate.

Aggregate root is a gateway to entire aggregate. Any references from outside the aggregate should only go to the aggregate root.

Any operations on an aggregate must be [transactional operations](https://en.wikipedia.org/wiki/Database_transaction). Either everything gets saved/updated/deleted or nothing.

Only Aggregate Roots can be obtained directly with database queries. Everything else must be done through traversal.

Similar to Entities, aggregates must protect their **invariants** through entire lifecycle. When a change to any object within the Aggregate boundary is committed, all **invariants** of the whole Aggregate must be satisfied. If one object inside an aggregate changes state, this shouldn't conflict with other domain objects inside this aggregate (this is called Consistency Boundary).

Objects within the Aggregate can reference other Aggregate roots via their globally unique identifier (id). Avoid holding a direct object reference.

Try to avoid aggregates that are too big, this can lead to performance and maintaining problems.

In summary, if you combine multiple related entities and value objects inside one root Entity, this root Entity becomes an **Aggregate Root**, and this cluster of related entities and value objects becomes an **Aggregate**.

Example code:
- [aggregate-root.base.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/libs/ddd/aggregate-root.base.ts) - abstract base class.
- [user.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/user.entity.ts) - aggregates are just entities that have to follow a set of specific rules described above.


## Domain Events

Domain Event indicates that something happened in a domain that you want other parts of the same domain (**in the same process**) to be aware of.

Domain events are just messages pushed to an in-memory Domain Event dispatcher.

For example, if a user buys something, you may want to:
- Update his shopping cart;
- Withdraw money from his wallet;
- Create a new shipping order;
- Perform other domain operations that are not a concern of an aggregate that executes a "buy" command.

If executing a command requires additional domain rules to be run on one or more additional aggregates, you can design and implement those side effects to be triggered by Domain Events. Propagation of state changes across multiple aggregates within the same domain model can be performed by subscribing to a concrete Domain Event and creating as many event handlers as needed. 

Domain Events may be useful for creating an audit log to track all changes to important entities by saving each event to the database.

All changes caused by Domain Events across multiple aggregates in a single process can be saved in a single database transaction. 

Example code:

- [user-created.domain-event.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/events/user-created.domain-event.ts) - simple object that holds data related to published event.
- [create-wallet-when-user-is-created.domain-event-handler.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/wallet/application/event-handlers/create-wallet-when-user-is-created.domain-event-handler.ts) - this is an example of Domain Event Handler that executes some actions when a domain event is raised (in this case, when user is created it also creates a wallet for that user).
- [sql-repository.base.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/libs/db/sql-repository.base.ts) - repository publishes all domain events for execution when it persists changes to an aggregate.
- [create-user.service.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.service.ts) - in a service we execute a global transaction to make sure all the changes done by Domain Events across the application are stored atomically (all or nothing).


## Integration Events

Integration Events are events sent to external process (microservices, external APIs).

Integration Events usually should be published only after all Domain Events finished executing and saving all changes to the database.

To handle integration events you may need an external message broker / event bus like RabbitMQ or Kafka together with patterns like Transactional outbox, Change Data Capture, Sagas or a Process Manager to maintain eventual consistency.


## Domain Services

Domain Service is a specific type of domain layer class that is used to execute domain logic that relies on two or more **Entities**.

Domain Services are used when putting the logic on a particular Entity would break encapsulation and require the **Entity** to know about things it really shouldn't be concerned with.

Domain services operate only on types belonging to the Domain. They contain meaningful concepts that can be found within the Ubiquitous Language. They hold operations that don't fit well into **Value Objects** or **Entities**.


## Value objects

Some Attributes and behaviors can be moved out of the entity itself and put into Value Objects.

Value Objects:

- Have no identity. Equality is determined through structural property.
- Are immutable.
- Can be used as an attribute of entities and other value objects.
- Explicitly defines and enforces important constraints (invariants).

Value object shouldn’t be just a convenient grouping of attributes but should form a well-defined concept in the domain model. This is true even if it contains only one attribute.

For example, imagine you have a **User** entity which needs to have an **address** of a user. Usually an address is simply a complex value that has no identity in the domain and is composed of multiple other values, like country, street, postalCode etc., so it can be modeled and treated as a **Value Object** with its own business logic.

**Value object** isn’t just a data structure that holds values. It can also encapsulate logic associated with the concept it represents.

Example code:
- [address.value-object.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/value-objects/address.value-object.ts)


## Domain Invariants

Domain [invariants](https://en.wikipedia.org/wiki/Invariant_(mathematics)#Invariants_in_computer_science) are the policies and conditions that are always met for the Domain in particular context. Invariants determine what is possible or what is prohibited in the context.

For example:

- When sending money, amount must always be a positive integer, and there always must be a receiver credit card number in a correct format;
- Client cannot purchase a product that is out of stock;
- Client's wallet cannot have less than 0 balance;

Domain objects (especially of the entities and aggregate roots) are responsible for enforcing invariants. They should not be able to exist without following business rules.

Example code:
- [wallet.entity.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/wallet/domain/wallet.entity.ts) (notice `validate` method. This is a simplified example of enforcing a domain invariant).


### Enforcing invariants using Value Objects

Most of the code bases operate on primitive types – `strings`, `numbers` etc. In the Domain Model, this level of abstraction may be too low.

Significant business concepts can be expressed using specific types and classes as **Value Objects**.

For example, `email` of type `string`:

```typescript
const email: string = 'john@gmail.com';
```

could be represented as a Value Object instead:

```typescript
export class Email extends ValueObject<string> {
  constructor(value: string) {
    super({ value });
  }

  get value(): string {
    return this.props.value;
  }
}

const email: Email = new Email('john@gmail.com');
```

Now the only way to make an email is to create a new instance of `Email` class first, this ensures it will be validated on creation and a wrong value won't get into **Entities**.

Using Value Objects for primitive types is also called a **domain primitive**. This allows behavior of the domain primitive to be encapsulated in one place. By having the domain primitive own and control domain operations, you reduce the risk of bugs caused by lack of detailed domain knowledge of the concepts involved in the operation.

Creating an object for primitive values may be cumbersome, but it somewhat forces a developer to study domain more in details instead of just throwing a primitive type without even thinking what that value represents in domain. The goal here is to encapsulate validations and business logic related only to the represented fields and make it impossible to pass around raw values by forcing a creation of valid **Value Objects** first.

Benefits of using Value Objects instead of primitives:

- Makes code easier to understand by using ubiquitous language instead of just string.
- Improves security by ensuring invariants of every property.
- Encapsulates specific business rules associated with a value.

If every argument and return value of a method is valid by definition (by using **Value Objects**), you’ll have input and output validation in every single method in your codebase without any extra effort. This will make application more resilient to errors and will protect it from a whole class of bugs and security vulnerabilities caused by invalid input data.

Without domain primitives, responsibilities fall on the entity code to validate, compare, and format the data, among other tasks. The entity code will be burdened with a lot of tasks, rather than focusing on the central business flow-of-state changes that it models. Using domain primitives can counteract the tendency for entities to grow overly complex.

> [!WARNING]
> Don't include Value Objects in objects that can be sent to other processes, like dtos, events, database models etc. Serialize them to primitive types first.

> [!INFO]
> This technique works best in languages like Scala with its value classes that represents such classes as primitives at runtime, meaning that object Email will be represented as String at runtime.

> [!INFO]
> if you are using nodejs, [Runtypes](https://www.npmjs.com/package/runtypes) is a nice library that you can use instead of creating your own value objects for primitives.

> [!NOTE]
> Some people consider making a class/object for every primitive may be overengineering (unless you are using Scala with its value classes). For less complex and smaller projects it's definitely an overkill.

If you notice that creating a class for every primitive doesn't give you much benefit:
1. create classes just for those primitives that have specific rules or behavior,
2. or just validate them only outside of domain using some validation framework.


### Validation at compile time

Use **types** to prevent errors at compile time, so IDE will show type errors right away.

For example, imagine that business logic requires to have contact info of a person by either having email, or phone, or both. This could be presented as a union type:

```typescript
type ContactInfo = Email | Phone | [Email, Phone];
```

Now only either Email, or Phone, or both must be provided. If nothing is provided, the IDE will show a type error right away. Now business rule validation is moved from runtime to compile time, which makes the application more secure and gives a faster feedback when something is not used as intended.

This is called a *typestate* pattern.


### Validation at runtime

There are a lot of cases when invalid data may end up in a domain. For example, if data comes from external API, database, or if it's just a programmer error. Things that can't be validated at compile time (like user input) are validated at runtime.

**First** line of defense is validation of user input DTOs.

**Second** line of defense are Domain Objects (guarding). Entities and value objects have to protect their invariants. You can use techniques like [Design by contract](https://en.wikipedia.org/wiki/Design_by_contract) by defining preconditions in object constructors and checking postconditions and invariants before saving an object to the database.

> [!TIP]
> By combining compile and runtime validations, using objects instead of primitives, enforcing self-validation and invariants of your domain objects, using **Design by contract**, [Algebraic Data Types (ADT)](https://en.wikipedia.org/wiki/Algebraic_data_type) and typestate pattern, and other similar techniques, you can achieve an architecture where it's hard, or even impossible, to end up in illegal states, thus improving security and robustness of your application dramatically (at a cost of extra boilerplate code).


## Guarding vs Validating

Validation happens at the application boundary (e.g., DTOs) to filter out incorrect external input before it reaches the domain.  

Guarding happens inside the domain layer to enforce invariants and ensure the domain model remains always valid.  

Validation is about filtration: rejecting bad input with error messages, nothing exceptional.  

Guarding is about failsafe protection: violations here indicate bugs and must throw exceptions.  

Once data passes validation, it is assumed valid inside the domain. Any violation inside the domain means that you’ve introduced a bug.

Guards reveal bugs early and follow the [Fail Fast principle](https://enterprisecraftsmanship.com/posts/fail-fast-principle) by immediately throwing runtime exceptions.  

Domain classes must always guard themselves against becoming invalid.


## Domain Errors

Application's core and domain layers **shouldn't throw HTTP exceptions** since it shouldn't know in what context it's used, since it can be used by anything: HTTP controller, Microservice event handler, Command Line Interface etc.

A better approach is to create custom error classes with appropriate error codes.

Exceptions are for exceptional situations. Complex domains usually have a lot of errors that are not exceptional, but a part of a business logic (like "seat already booked, choose another one"). Those errors may need special handling. In those cases returning explicit error types can be a better approach than throwing.

Returning an error instead of throwing explicitly shows a type of each exception that a method can return so you can handle it accordingly. It can make an error handling and tracing easier.

You can create an [Algebraic Data Types (ADT)](https://en.wikipedia.org/wiki/Algebraic_data_type) for your errors and use some kind of Result object type with a Success or a Failure condition.

Unlike throwing exceptions, this approach allows defining types (ADTs) for every error and will let you see and handle them explicitly instead of using try/catch and avoid throwing exceptions that are invisible at compile time.

**Throwing** makes errors invisible for the consumer of your functions/methods (until those errors happen at runtime, or until you dig deeply into the source code and find them). This means those errors are less likely to be handled properly.

**Returning** errors instead of throwing them adds some extra boilerplate code, but can make your application robust and secure since errors are now explicitly documented and visible as return types. You decide what to do with each error: propagate it further, transform it, add extra metadata, or try to recover from it (for example, by retrying the operation).

> [!WARNING]
> Some errors/exceptions are non-recoverable and should be thrown, not returned (connection failed, process out of memory, etc.). Analyze if the error is "likely recoverable" or "likely unrecoverable". If an error is most likely a recoverable error, it's a great candidate for using it in a Result object. If an error is most likely unrecoverable, throw it.

Example code:
- [user.errors.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/user.errors.ts) - user errors
- [create-user.service.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.service.ts) - `UserAlreadyExistsError()` is returned instead of throwing it.


## Using libraries inside Application's core

Libraries imported in application's core should be single responsibility libraries that help to implement domain logic (like working with numbers).

Libraries imported in application's core shouldn't:
- Expose functionality to access any out-of-process resources (http calls, database access etc);
- Expose functionality not relevant to domain (frameworks, technology details like ORMs, Logger etc.).
- Expose functionality that brings randomness (generating random IDs, timestamps etc.) since this makes tests unpredictable
- Have a lot of dependencies of its own 

You should be able to extract your domain layer and build a new infrastructure around it using any other framework without breaking your business logic.

Try to minimize what your software depends on (dependencies) - the less that can go wrong, the less will go wrong. Finding a good balance is important, this skill requires experience.
