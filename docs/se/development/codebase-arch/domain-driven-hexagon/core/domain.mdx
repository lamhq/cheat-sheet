# Domain

## Introduction

This layer contains the application's business rules.

Should be framework/technologies-agnostic, allow to rebuild infrastructure without breaking business logic.

Should operate using domain objects described by [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html).

Should minimize dependencies to reduce potential issues, balancing simplicity and functionality.

Most important domain building blocks are:
- **Entities**: domain objects with identity (ID) and behavior.
- **Aggregates**: similar to entities, but encapsulate a cluster of domain objects.
- **Value Objects**: wrap one or multiple attributes and the logic associated with those attributes; has no identity.
- **Domain Services**: coordinate logic across multiple Entities..
- **Domain Events**: capture and broadcast significant changes in the domain.
- **Domain Errors**: explicit error handling using result objects instead of exceptions.


## Entities

Entities represent business rules and attributes. They can be objects with properties and methods or data structures with functions.

Entities define:
- Properties a model has.
- Actions it can perform.
- Conditions for those actions.

Examples: *User*, *Product*, *Booking*, *Ticket*, *Wallet*.

Equality between entities is based on their identifiers (e.g., `id`).

Entities can include other entities or value objects. Always validate entities during creation and enforce invariants. For example, an order item must have:
- A positive quantity.
- An article name.
- A price.

Protect invariants by avoiding public setters. Use methods to update state and validate changes.

Avoid constructors without arguments. Validate required properties in constructors or [factory methods](https://en.wikipedia.org/wiki/Factory_method_pattern).

Make entities partially immutable. Properties like `id` or `createdAt` should be readonly.

Avoid placing business logic in Application Services unless necessary. This prevents [Anemic Domain Model](https://martinfowler.com/bliki/AnemicDomainModel.html). Domain Services are exceptions.

> [!CAUTION]
> Avoid creating one module per entity. Group related entities with shared business logic in a module.

Example code:
- [user.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/user.entity.ts)
- [wallet.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/wallet/domain/wallet.entity.ts)


## Aggregates

An **Aggregate** is a cluster of related domain objects (entities and value objects) that are treated as a single unit for consistency. It defines clear boundaries around which rules and invariants must hold true.  

The **Aggregate Root** is the main entity within that cluster:  
- Itâ€™s the **entry point** to the aggregate.  
- All external interactions go through it, ensuring rules are enforced consistently.  
- It controls access to other entities inside the aggregate, protecting invariants.  

For example: *In an e-commerce system, an **Order** is an aggregate root. It manages order items (entities) and ensures rules like "an order must have at least one item" are always respected*.  

Designing aggregates should not be influenced by the data model. Associations between domain objects are not the same as database relationships.

Only reference the Aggregate Root from outside the aggregate.

Avoid direct object references between aggregates; use unique identifiers instead.

All changes to an aggregate must be saved, updated, or deleted together.

Changes within an aggregate must maintain invariants and consistency. Protect invariants across the entire aggregate lifecycle.

Example Code:
- [aggregate-root.base.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/libs/ddd/aggregate-root.base.ts) - Abstract base class.
- [user.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/user.entity.ts) - Example of an aggregate root.


## Value objects

**Value Objects** are domain concepts that are defined by their **attributes**, not by identity.

Unlike entities, they don't have a unique identifier and are considered equal if all their properties match.  

Value object should form a well-defined concept in the domain model, even if it contains only one attribute.

**Key Characteristics**:
- **No identity**: Two value objects with the same values are indistinguishable.  
- **Immutable**: Once created, they cannot be changed; instead, a new instance is created if values differ.  
- **Behavior-focused**: They can contain logic relevant to their values (e.g., validation, formatting).  
- **Lightweight**: Often used to model concepts like money, dates, addresses, or email addresses.  

**Examples**:
- **EmailAddress** value object ensures the string is valid. If two email addresses have the same value, they are equal.  
- **Address** of a user is composed of multiple other values, like country, street, postalCode etc., so it can be modeled and treated as a **Value Object** with its own business logic.

Example code:
- [address.value-object.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/value-objects/address.value-object.ts)


## Domain Services

Domain Services execute logic involving two or more **Entities**. 

They are used when placing logic in an **Entity** would break encapsulation or require the **Entity** to handle unrelated concerns. They hold operations that don't fit well into **Value Objects** or **Entities**.

Domain services operate only on types belonging to the Domain. They contain meaningful concepts that can be found within the Ubiquitous Language.


## Domain Invariants

Domain [invariants](https://en.wikipedia.org/wiki/Invariant_(mathematics)#Invariants_in_computer_science) are rules that must always hold true in a specific context. They define what is allowed or prohibited.

Examples:
- Money transfers require a positive amount and a valid receiver card number.
- Products out of stock cannot be purchased.
- Wallet balances cannot drop below zero.

Domain objects (entities, aggregate roots, value objects) enforce invariants to ensure business rules are followed.

Example code:
- [wallet.entity.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/wallet/domain/wallet.entity.ts) (see `validate` method).


### Enforcing invariants using Value Objects

Primitive types like `strings` and `numbers` are often too basic for Domain Models. Significant business concepts could use **Value Objects** to encapsulate logic and validation.

For example, an email with type string:
```typescript
const email: string = 'john@gmail.com';
```
can become:
```typescript
export class Email extends ValueObject<string> {
  constructor(value: string) {
    super({ value });
  }

  get value(): string {
    return this.props.value;
  }
}
```

Now the only way to make an email is to create a new instance of `Email` class first, this ensures it will be validated on creation and a wrong value won't get into **Entities**.

Using **Value Objects** for primitive types, also called **domain primitives**, encapsulates behavior and reduces bugs caused by lack of domain knowledge.

Creating objects for primitives ensures validation and encapsulates business logic. This prevents passing raw values and enforces rules.

**Benefits:**
- Simplifies code with ubiquitous language.
- Ensures property invariants and improves security.
- Encapsulates specific business rules.

> [!WARNING]
> Serialize **Value Objects** to primitives before sending them to other processes (e.g., DTOs, events).

> [!INFO]
> Libraries like [Runtypes](https://www.npmjs.com/package/runtypes) simplify creating **Value Objects** in Node.js.

If creating classes for all primitives feels excessive:
1. Use classes only for primitives that have specific rules or behavior.
2. Validate them outside the domain using libraries or frameworks.


### Validation at compile time

Use **types** to catch errors early during development.

For example, enforce business rules like requiring contact info to include either an email, phone, or both:

```typescript
type ContactInfo = Email | Phone | [Email, Phone];
```

Now only either Email, or Phone, or both must be provided. If nothing is provided, the IDE will show a type error right away. Now business rule validation is moved from runtime to compile time, which makes the application more secure and gives a faster feedback when something is not used as intended.

This is called a *typestate* pattern.


### Validation at runtime

Invalid data can enter a domain at runtime (from APIs, databases, or programming errors). 

Runtime validation is required to ensure data integrity.

**Steps:**
1. Validate input DTOs (validating).
2. Domain objects protect their invariants (guarding) by defining preconditions (in constructor) and checking postconditions and invariants before saving an object to the database.


### Guarding vs Validating

- **Validation**: Filters bad input at application boundaries (e.g., DTOs). Returns errors for invalid data.
- **Guarding**: Enforces invariants within the domain. Violations indicate bugs and must throw exceptions.

Guards follow the [Fail Fast principle](https://enterprisecraftsmanship.com/posts/fail-fast-principle) by immediately throwing runtime exceptions, which helps revealing bugs early.


## Domain Events

A **Domain Event** signals that something significant occurred within the domain, notifying other parts of the same domain (**in the same process**).

Domain Events are messages sent to an in-memory dispatcher. For example, when a user makes a purchase, you might:
- Update their shopping cart.
- Deduct money from their wallet.
- Create a shipping order.
- Trigger other domain-specific operations unrelated to the "buy" command.

If a command affects multiple aggregates, you can design and implement those side effects to be triggered by Domain Events. Handlers can subscribe to these events to propagate state changes across aggregates. 

Domain Events are also useful for creating audit logs by saving events to the database. Changes triggered by Domain Events can be saved in a single database transaction.

**Examples:**
- [user-created.domain-event.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/events/user-created.domain-event.ts): Holds event data.
- [create-wallet-when-user-is-created.domain-event-handler.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/wallet/application/event-handlers/create-wallet-when-user-is-created.domain-event-handler.ts): Handles events (e.g., creating a wallet when a user is created).
- [sql-repository.base.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/libs/db/sql-repository.base.ts): Publishes events when persisting aggregates.
- [create-user.service.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.service.ts): Executes global transactions to ensure atomic changes across events.


## Integration Events

**Integration Events** are events sent to external processes (e.g., microservices, APIs). They should only be published after all **Domain Events** are processed and changes are saved.

To handle these events, use external tools like RabbitMQ or Kafka, along with patterns such as:
- Transactional Outbox
- Change Data Capture
- Sagas
- Process Manager

These ensure eventual consistency across systems.


## Domain Errors

The core and domain layers **shouldn't throw HTTP exceptions** since they are context-agnostic and may be used in various environments (e.g., HTTP controllers, CLI tools).

Instead, use custom error classes with appropriate error codes. This approach:
- Makes error handling and tracing easier.
- Explicitly shows the types of errors a method can return.
- Avoids invisible runtime exceptions.

**Throwing exceptions** is suitable for unrecoverable errors (e.g., out of memory). For recoverable errors, return explicit error types using [Algebraic Data Types (ADT)](https://en.wikipedia.org/wiki/Algebraic_data_type) or a Result object with Success/Failure conditions. This ensures errors are visible and manageable.

**Benefits of returning errors:**
- Explicitly documents error types.
- Allows handling errors (e.g., retrying, transforming, or propagating).
- Improves robustness and security.

> [!WARNING]
> Use exceptions for non-recoverable errors (e.g., connection failures).

**Examples:**
- [user.errors.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/user.errors.ts): Defines user-related errors.
- [create-user.service.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.service.ts): Returns `UserAlreadyExistsError()` instead of throwing it.
