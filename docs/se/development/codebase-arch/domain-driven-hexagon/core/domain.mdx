# Domain

## Introduction

This layer contains the application's business rules.

Should operate using domain objects described by [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html).

Completely independent of frameworks, databases, or external technologies.

Most important domain building blocks are:
- **Entities**: domain objects with identity (ID) and behavior.
- **Aggregates**: similar to entities, but encapsulate a cluster of domain objects.
- **Value Objects**: wrap one or multiple attributes and the logic associated with those attributes; has no identity.
- **Domain Services**: coordinate logic across multiple Entities..
- **Domain Events**: capture and broadcast significant changes in the domain.
- **Domain Errors**: explicit error handling using result objects instead of exceptions.


## Entities

Entities represent business rules and attributes. They can be objects with properties and methods or data structures with functions.

Entities define:
- Properties a model has.
- Actions it can perform.
- Conditions for those actions.

Examples: *User*, *Product*, *Booking*, *Ticket*, *Wallet*.

Equality between entities is based on their identifiers (e.g., `id`).

Entities can include other entities or value objects. Always validate entities during creation and enforce invariants. For example, an order item must have:
- A positive quantity.
- An article name.
- A price.

Protect invariants by avoiding public setters. Use methods to update state and validate changes.

Avoid constructors without arguments. Validate required properties in constructors or [factory methods](https://en.wikipedia.org/wiki/Factory_method_pattern).

Make entities partially immutable. Properties like `id` or `createdAt` should be readonly.

Avoid placing business logic in Application Services unless necessary. This prevents [Anemic Domain Model](https://martinfowler.com/bliki/AnemicDomainModel.html). Domain Services are exceptions.

> [!CAUTION]
> Avoid creating one module per entity. Group related entities with shared business logic in a module.

Example code:
- [user.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/user.entity.ts)
- [wallet.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/wallet/domain/wallet.entity.ts)


## Aggregates

An **Aggregate** is a cluster of related domain objects (entities and value objects) that are treated as a single unit for consistency. It defines clear boundaries around which rules and invariants must hold true.  

The **Aggregate Root** is the main entity within that cluster:  
- It’s the **entry point** to the aggregate.  
- All external interactions go through it, ensuring rules are enforced consistently.  
- It controls access to other entities inside the aggregate, protecting invariants.  

For example: *In an e-commerce system, an **Order** is an aggregate root. It manages order items (entities) and ensures rules like "an order must have at least one item" are always respected*.  

Designing aggregates should not be influenced by the data model. Associations between domain objects are not the same as database relationships.

Only reference the Aggregate Root from outside the aggregate.

Avoid direct object references between aggregates; use unique identifiers instead.

All changes to an aggregate must be saved, updated, or deleted together.

Changes within an aggregate must maintain invariants and consistency. Protect invariants across the entire aggregate lifecycle.

Example Code:
- [aggregate-root.base.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/libs/ddd/aggregate-root.base.ts) - Abstract base class.
- [user.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/user.entity.ts) - Example of an aggregate root.


## Value objects

Some Attributes and behaviors can be moved out of the entity itself and put into Value Objects.

Value Objects:

- Have no identity. Equality is determined through structural property.
- Are immutable.
- Can be used as an attribute of entities and other value objects.
- Explicitly defines and enforces important constraints (invariants).

Value object shouldn’t be just a convenient grouping of attributes but should form a well-defined concept in the domain model. This is true even if it contains only one attribute.

For example, imagine you have a **User** entity which needs to have an **address** of a user. Usually an address is simply a complex value that has no identity in the domain and is composed of multiple other values, like country, street, postalCode etc., so it can be modeled and treated as a **Value Object** with its own business logic.

**Value object** isn’t just a data structure that holds values. It can also encapsulate logic associated with the concept it represents.

Example code:
- [address.value-object.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/value-objects/address.value-object.ts)


## Domain Services

Domain Service is a specific type of domain layer class that is used to execute domain logic that relies on two or more **Entities**.

Domain Services are used when putting the logic on a particular Entity would break encapsulation and require the **Entity** to know about things it really shouldn't be concerned with.

Domain services operate only on types belonging to the Domain. They contain meaningful concepts that can be found within the Ubiquitous Language. They hold operations that don't fit well into **Value Objects** or **Entities**.


## Domain Invariants

Domain [invariants](https://en.wikipedia.org/wiki/Invariant_(mathematics)#Invariants_in_computer_science) are the policies and conditions that are always met for the Domain in particular context. Invariants determine what is possible or what is prohibited in the context.

For example:

- When sending money, amount must always be a positive integer, and there always must be a receiver credit card number in a correct format;
- Client cannot purchase a product that is out of stock;
- Client's wallet cannot have less than 0 balance;

Domain objects (especially of the entities and aggregate roots) are responsible for enforcing invariants. They should not be able to exist without following business rules.

Example code:
- [wallet.entity.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/wallet/domain/wallet.entity.ts) (notice `validate` method. This is a simplified example of enforcing a domain invariant).


### Enforcing invariants using Value Objects

Most of the code bases operate on primitive types – `strings`, `numbers` etc. In the Domain Model, this level of abstraction may be too low.

Significant business concepts can be expressed using specific types and classes as **Value Objects**.

For example, `email` of type `string`:

```typescript
const email: string = 'john@gmail.com';
```

could be represented as a Value Object instead:

```typescript
export class Email extends ValueObject<string> {
  constructor(value: string) {
    super({ value });
  }

  get value(): string {
    return this.props.value;
  }
}

const email: Email = new Email('john@gmail.com');
```

Now the only way to make an email is to create a new instance of `Email` class first, this ensures it will be validated on creation and a wrong value won't get into **Entities**.

Using Value Objects for primitive types is also called a **domain primitive**. This allows behavior of the domain primitive to be encapsulated in one place. By having the domain primitive own and control domain operations, you reduce the risk of bugs caused by lack of detailed domain knowledge of the concepts involved in the operation.

Creating an object for primitive values may be cumbersome, but it somewhat forces a developer to study domain more in details instead of just throwing a primitive type without even thinking what that value represents in domain. The goal here is to encapsulate validations and business logic related only to the represented fields and make it impossible to pass around raw values by forcing a creation of valid **Value Objects** first.

Benefits of using Value Objects instead of primitives:

- Makes code easier to understand by using ubiquitous language instead of just string.
- Improves security by ensuring invariants of every property.
- Encapsulates specific business rules associated with a value.

If every argument and return value of a method is valid by definition (by using **Value Objects**), you’ll have input and output validation in every single method in your codebase without any extra effort. This will make application more resilient to errors and will protect it from a whole class of bugs and security vulnerabilities caused by invalid input data.

Without domain primitives, responsibilities fall on the entity code to validate, compare, and format the data, among other tasks. The entity code will be burdened with a lot of tasks, rather than focusing on the central business flow-of-state changes that it models. Using domain primitives can counteract the tendency for entities to grow overly complex.

> [!WARNING]
> Don't include Value Objects in objects that can be sent to other processes, like dtos, events, database models etc. Serialize them to primitive types first.

> [!INFO]
> This technique works best in languages like Scala with its value classes that represents such classes as primitives at runtime, meaning that object Email will be represented as String at runtime.

> [!INFO]
> if you are using nodejs, [Runtypes](https://www.npmjs.com/package/runtypes) is a nice library that you can use instead of creating your own value objects for primitives.

> [!NOTE]
> Some people consider making a class/object for every primitive may be overengineering (unless you are using Scala with its value classes). For less complex and smaller projects it's definitely an overkill.

If you notice that creating a class for every primitive doesn't give you much benefit:
1. create classes just for those primitives that have specific rules or behavior,
2. or just validate them only outside of domain using some validation framework.


### Validation at compile time

Use **types** to prevent errors at compile time, so IDE will show type errors right away.

For example, imagine that business logic requires to have contact info of a person by either having email, or phone, or both. This could be presented as a union type:

```typescript
type ContactInfo = Email | Phone | [Email, Phone];
```

Now only either Email, or Phone, or both must be provided. If nothing is provided, the IDE will show a type error right away. Now business rule validation is moved from runtime to compile time, which makes the application more secure and gives a faster feedback when something is not used as intended.

This is called a *typestate* pattern.


### Validation at runtime

There are a lot of cases when invalid data may end up in a domain. For example, if data comes from external API, database, or if it's just a programmer error. Things that can't be validated at compile time (like user input) are validated at runtime.

**First** line of defense is validation of user input DTOs.

**Second** line of defense are Domain Objects (guarding). Entities and value objects have to protect their invariants. You can use techniques like [Design by contract](https://en.wikipedia.org/wiki/Design_by_contract) by defining preconditions in object constructors and checking postconditions and invariants before saving an object to the database.

> [!TIP]
> By combining compile and runtime validations, using objects instead of primitives, enforcing self-validation and invariants of your domain objects, using **Design by contract**, [Algebraic Data Types (ADT)](https://en.wikipedia.org/wiki/Algebraic_data_type) and typestate pattern, and other similar techniques, you can achieve an architecture where it's hard, or even impossible, to end up in illegal states, thus improving security and robustness of your application dramatically (at a cost of extra boilerplate code).


### Guarding vs Validating

Validation happens at the application boundary (e.g., DTOs) to filter out incorrect external input before it reaches the domain.  

Guarding happens inside the domain layer to enforce invariants and ensure the domain model remains always valid.  

Validation is about filtration: rejecting bad input with error messages, nothing exceptional.  

Guarding is about failsafe protection: violations here indicate bugs and must throw exceptions.  

Once data passes validation, it is assumed valid inside the domain. Any violation inside the domain means that you’ve introduced a bug.

Guards reveal bugs early and follow the [Fail Fast principle](https://enterprisecraftsmanship.com/posts/fail-fast-principle) by immediately throwing runtime exceptions.  

Domain classes must always guard themselves against becoming invalid.


## Domain Events

Domain Event indicates that something happened in a domain that you want other parts of the same domain (**in the same process**) to be aware of.

Domain events are just messages pushed to an in-memory Domain Event dispatcher.

For example, if a user buys something, you may want to:
- Update his shopping cart;
- Withdraw money from his wallet;
- Create a new shipping order;
- Perform other domain operations that are not a concern of an aggregate that executes a "buy" command.

If executing a command requires additional domain rules to be run on one or more additional aggregates, you can design and implement those side effects to be triggered by Domain Events. Propagation of state changes across multiple aggregates within the same domain model can be performed by subscribing to a concrete Domain Event and creating as many event handlers as needed. 

Domain Events may be useful for creating an audit log to track all changes to important entities by saving each event to the database.

All changes caused by Domain Events across multiple aggregates in a single process can be saved in a single database transaction. 

Example code:

- [user-created.domain-event.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/events/user-created.domain-event.ts) - simple object that holds data related to published event.
- [create-wallet-when-user-is-created.domain-event-handler.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/wallet/application/event-handlers/create-wallet-when-user-is-created.domain-event-handler.ts) - this is an example of Domain Event Handler that executes some actions when a domain event is raised (in this case, when user is created it also creates a wallet for that user).
- [sql-repository.base.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/libs/db/sql-repository.base.ts) - repository publishes all domain events for execution when it persists changes to an aggregate.
- [create-user.service.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.service.ts) - in a service we execute a global transaction to make sure all the changes done by Domain Events across the application are stored atomically (all or nothing).


## Integration Events

Integration Events are events sent to external process (microservices, external APIs).

Integration Events usually should be published only after all Domain Events finished executing and saving all changes to the database.

To handle integration events you may need an external message broker / event bus like RabbitMQ or Kafka together with patterns like Transactional outbox, Change Data Capture, Sagas or a Process Manager to maintain eventual consistency.


## Domain Errors

Application's core and domain layers **shouldn't throw HTTP exceptions** since it shouldn't know in what context it's used, since it can be used by anything: HTTP controller, Microservice event handler, Command Line Interface etc.

A better approach is to create custom error classes with appropriate error codes.

Exceptions are for exceptional situations. Complex domains usually have a lot of errors that are not exceptional, but a part of a business logic (like "seat already booked, choose another one"). Those errors may need special handling. In those cases returning explicit error types can be a better approach than throwing.

Returning an error instead of throwing explicitly shows a type of each exception that a method can return so you can handle it accordingly. It can make an error handling and tracing easier.

You can create an [Algebraic Data Types (ADT)](https://en.wikipedia.org/wiki/Algebraic_data_type) for your errors and use some kind of Result object type with a Success or a Failure condition.

Unlike throwing exceptions, this approach allows defining types (ADTs) for every error and will let you see and handle them explicitly instead of using try/catch and avoid throwing exceptions that are invisible at compile time.

**Throwing** makes errors invisible for the consumer of your functions/methods (until those errors happen at runtime, or until you dig deeply into the source code and find them). This means those errors are less likely to be handled properly.

**Returning** errors instead of throwing them adds some extra boilerplate code, but can make your application robust and secure since errors are now explicitly documented and visible as return types. You decide what to do with each error: propagate it further, transform it, add extra metadata, or try to recover from it (for example, by retrying the operation).

> [!WARNING]
> Some errors/exceptions are non-recoverable and should be thrown, not returned (connection failed, process out of memory, etc.). Analyze if the error is "likely recoverable" or "likely unrecoverable". If an error is most likely a recoverable error, it's a great candidate for using it in a Result object. If an error is most likely unrecoverable, throw it.

Example code:
- [user.errors.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/user.errors.ts) - user errors
- [create-user.service.ts](https://github.com/Sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.service.ts) - `UserAlreadyExistsError()` is returned instead of throwing it.


## Using libraries inside Application's core

Libraries imported in application's core should be single responsibility libraries that help to implement domain logic (like working with numbers).

Libraries imported in application's core shouldn't:
- Expose functionality to access any out-of-process resources (http calls, database access etc);
- Expose functionality not relevant to domain (frameworks, technology details like ORMs, Logger etc.).
- Expose functionality that brings randomness (generating random IDs, timestamps etc.) since this makes tests unpredictable
- Have a lot of dependencies of its own 

You should be able to extract your domain layer and build a new infrastructure around it using any other framework without breaking your business logic.

Try to minimize what your software depends on (dependencies) - the less that can go wrong, the less will go wrong. Finding a good balance is important, this skill requires experience.
