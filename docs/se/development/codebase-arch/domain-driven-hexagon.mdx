# Domain-Driven Hexagon

## Pros & Cons

Pros:
- Independent of external frameworks, technologies, databases, etc. Frameworks and external resources can be plugged/unplugged with much less effort.
- Testable.
- Secure. Some security principles are baked into the design itself.
- Clear separation of concerns. Different teams can contribute and maintain together without stepping on each other's toes.
- Scalable. Easier to add new features. The difficulty of adding new features remains constant and relatively small.

Cons:
- Sophisticated architecture. Requires an expert to drive the solution and prevent it from evolving in the wrong way and accumulating technical debt.
- Added up-front complexity to support all those building blocks and layers, boilerplate code, abstractions, data mapping, etc. Not recommended for small/medium-sized applications with limited business logic.


## Data Flow

![](https://github.com/Sairyss/domain-driven-hexagon/blob/master/assets/images/DomainDrivenHexagon.png?raw=true)

Data flow (from left to right in the diagram):
1. **Request/CLI command/event** is sent to the controller using a plain **DTO**.
2. **Controller** parses this DTO, maps it to a **Command/Query object** format, and passes it to an Application service.
3. **Application service** handles this Command/Query, executes business logic using **domain services** and **entities/aggregates**, and uses the infrastructure layer through ports (interfaces).
4. **Infrastructure layer**:
   - Maps data to the required format.
   - Retrieves/persists data from/to a database.
   - Uses **adapters** for other I/O communications (e.g., sending an event to an external broker or calling external APIs).
   - Maps data back to the domain format and returns it to the Application service.
5. After the Application service finishes its job, it returns data/confirmation back to **Controllers**.
6. **Controllers** return data back to the user (if the application has presenters/views, those are returned instead).

Each layer is responsible for its own logic and follows the Single Responsibility Principle.

Different projects can have more or fewer steps/layers/building blocks.

## Modules

The codebase uses the principle of separation by modules to ensure loose coupling:
- Refactoring of a module's internals can be done more easily because the outside world only depends on the module's public interface.
- Each module can be easily separated into a microservice if needed, without touching any domain logic or requiring major refactoring (if bounded contexts are designed properly).

Each module should reflect an important concept from the Domain and have its own folder as a dedicated codebase.

Each module contains business use cases, each in its own folder.

Think of a module as a "box" that groups together related business logic, or a mini-application bounded by a single context.

Keep your modules small. It should be possible to rewrite a module in a relatively short period of time.

A few pieces of advice to avoid coupling:
- Every module should be independent, and interactions between modules should be kept minimal.
- Try not to create dependencies between modules or use cases. Instead, move shared logic into separate files and make both depend on that, rather than on each other.
- Avoid directly importing a module's internal components, as this creates tight coupling and can turn your code into [spaghetti](https://en.wikipedia.org/wiki/Spaghetti_code) and your application into a [big ball of mud](https://en.wikipedia.org/wiki/Big_ball_of_mud).
- Modules can cooperate through a [mediator](https://en.wikipedia.org/wiki/Mediator_pattern#:~:text=In%20software%20engineering%2C%20the%20mediator,often%20consist%20of%20many%20classes.) or a public [facade](https://en.wikipedia.org/wiki/Facade_pattern), hiding all private internals of the module to avoid misuse, and giving public access only to certain functionality meant to be public.
- Modules can communicate with each other by using messages. *For example, you can send commands using a command bus or subscribe to events that other modules emit.*

Each module consists of layers:
- Application Layer
- Domain Layer
- Interface Adapters
- Infrastructure Layer

## Application Layer

### Application Services

Application Services are used to orchestrate the steps required to fulfill the commands imposed by the client.

Application services:
- Typically orchestrate how the outside world interacts with your application and perform tasks required by end users.
- Contain no domain-specific business logic.
- Operate on scalar types, transforming them into Domain types. A scalar type includes primitive types and types that don't belong to the Domain.
- Use **ports** (interfaces) to declare dependencies on infrastructural services/adapters required to execute domain logic.
- Fetch domain `Entities`/`Aggregates` (or other objects) from databases/external APIs (through ports/interfaces, with concrete implementations injected by the [DI](https://en.wikipedia.org/wiki/Dependency_injection) library).
- Execute domain logic on `Entities`/`Aggregates` (by invoking their methods).
- When working with multiple `Entities`/`Aggregates`, use a `Domain Service` to orchestrate them.
- Execute other out-of-process communications through Ports (e.g., event emission, sending emails).
- Can be used as `Command`/`Query` handlers.
- Should not depend on other application services, as this may cause problems (such as cyclic dependencies).

One service per use case is considered good practice.

> [!INFO]  
> A use case is a list of actions/steps defining the interactions between an actor (UML) and a system to achieve a goal.

Example code:
- [`create-user.service.ts`](https://github.com/Sairyss/domain-driven-hexagon/blob/master/https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.service.ts)


### Commands and Queries

Methods should be separated into Commands (state-changing operations) and Queries (data-retrieval operations).

Before a DTO reaches the domain, it's converted into a Command/Query object.

By enforcing `Command` and `Query` separation, the code becomes simpler to understand. One changes something, another just retrieves data.

Following CQS from the start will facilitate separating write and read models into different databases if someday in the future the need for it arises.


#### Command

A `Command` is an object that signals user intent, for example `CreateUserCommand`. It describes a single action (but does not perform it).

`Commands` are used for state-changing actions, such as creating a new user and saving it to the database. Create, Update, and Delete operations are considered state-changing.

`Command` methods can return the ID of a created item, a redirect link, a confirmation message, a status, or other metadata.

You use a `Command Bus` to execute a command instead of importing a service directly. This decouples a command Invoker from a Receiver, so you can send your commands from anywhere without creating coupling.

Avoid command handlers executing other commands (Command → Command). Instead, use events for that purpose, and execute subsequent commands in a chain within an Event handler (Command → Event → Command).

Example code:
- [create-user.command.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.command.ts) – a command object.
- [create-user.message.controller.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.message.controller.ts) – controller executes a command using a command bus. This decouples it from a command handler.
- [create-user.service.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.service.ts) – a command handler.


#### Queries

`Query` is similar to a `Command`. It belongs to a read model and signals user intent to find something and describes how to do it.

`Query` is just a data retrieval operation and should not make any state changes (like writes to the database, files, third party APIs, etc.). For this reason, in read model we can bypass a domain and repository layers completely and query database directly from a query handler.

You use a `Query Bus` to execute a query without importing classes directly and avoid coupling.

Example code:
- [find-users.query-handler.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/queries/find-users/find-users.query-handler.ts) - a query handler. Notice how we query the database directly, without using domain objects or repositories (more info [here](https://codeopinion.com/should-you-use-the-repository-pattern-with-cqrs-yes-and-no/)).

> [!NOTE]
> This guide uses [NestJS CQRS](https://docs.nestjs.com/recipes/cqrs) package that provides a command/query bus.


### Ports

Ports are interfaces that define contracts that should be implemented by adapters.

Ports can be created to abstract side effects like I/O operations and database access, technology details, invasive libraries, legacy code etc. from the Domain.

Ports should be created to fit the Domain needs, not simply mimic the tools APIs.

Any external calls to extenal systems or remote processes should be done through ports (interfaces), implementations is created somewhere in infrastructure layer and injected into application's core through [DI](https://en.wikipedia.org/wiki/Dependency_injection). This makes business logic independent of technology, facilitates testing, allows to plug/unplug/swap any external resources easily making application modular and loosely coupled.

When designing ports, split large interfaces into smaller ones when it makes sense, but also keep in mind to not overdo it when not necessary ([Interface segregation principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)).

To avoid [unnecessary abstractions](https://mortoray.com/2014/08/01/the-false-abstraction-antipattern/) and overcomplicate your application, only use ports for things might change in the future (database, external APIs, frameworks etc.).

Example code:
- [repository.port.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/libs/ddd/repository.port.ts) - generic port for repositories
- [user.repository.port.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/database/user.repository.port.ts) - a port for user repository
- [find-users.query-handler.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/queries/find-users/find-users.query-handler.ts) - notice how query handler depends on a port instead of concrete repository implementation, and an implementation is injected
- [logger.port.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/libs/ports/logger.port.ts) - another example of a port for application logger

Benefits:
- You can test your application logic in isolation by mocking the implementation.
- Abstraction provided by ports can be used to inject different implementations to a port if needed
- Ports can also help to delay decisions. The Domain layer can be implemented even before deciding what technologies (frameworks, databases etc.) will be used.


## Domain Layer

This layer contains the application's business rules.

Domain should operate using domain objects described by [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html).

Most important domain building blocks are described below:


### Entities

Entities encapsulate enterprise-wide business rules and attributes. An entity can be an object with properties and methods, or it can be a set of data structures and functions.

Entities express what properties a particular model has, what it can do, when and at what conditions it can do it.

Examples: User, Product, Booking, Ticket, Wallet etc.

Avoid having business logic in your services when possible, this leads to [Anemic Domain Model](https://martinfowler.com/bliki/AnemicDomainModel.html) (Domain Services are an exception for business logic that can't be put in a single entity).

Equality between two entities is determined by comparing their identificators (usually its `id` field).

Entities can contain other objects, such as other entities or value objects.

Entities should always be valid. Validate Entities and other domain objects on creation and throw an error on first failure. *For example, an order item object always has to have a quantity that must be a positive integer, plus an article name and price*.

Entities must protect their invariants, try to avoid public setters - update state using methods and execute invariant validation on each update if needed (this can be a simple `validate()` method that checks if business rules are not violated by update).

When creating entities, avoid no-arg (empty) constructors, accept and validate all required properties in a constructor (or in a [factory method](https://en.wikipedia.org/wiki/Factory_method_pattern) like `create()`).

Make Entities partially immutable. Identify what properties shouldn't change after creation and make them readonly (for example `id` or `createdAt`).

> [!CAUTION]
> It's not recommended to create one module per entity. Each module may have multiple entities, and those entities need to have related business logic, don't group unrelated entities in one module.

Example code:
- [user.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/user.entity.ts)
- [wallet.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/wallet/domain/wallet.entity.ts)


### Aggregates

**Aggregate** is a cluster of domain objects, it encapsulates entities and value objects which conceptually belong together. It also contains a set of operations which those domain objects can be operated on.

Aggregates help to simplify the domain model by gathering multiple domain objects under a single abstraction.

Aggregates should not be influenced by the data model. Associations between domain objects are not the same as database relationships.

**Aggregate root** is an entity that contains other entities/value objects and all logic to operate them.

Aggregate root has global identity (UUID / GUID / primary key). Entities inside the aggregate boundary have local identities, unique only within the Aggregate.

Aggregate root is a gateway to entire aggregate. Any references from outside the aggregate should only go to the aggregate root.

Any operations on an aggregate must be [transactional operations](https://en.wikipedia.org/wiki/Database_transaction). Either everything gets saved/updated/deleted or nothing.

Only Aggregate Roots can be obtained directly with database queries. Everything else must be done through traversal.

Similar to Entities, aggregates must protect their invariants through entire lifecycle. When a change to any object within the Aggregate boundary is committed, all invariants of the whole Aggregate must be satisfied. If one object inside an aggregate changes state, this shouldn't conflict with other domain objects inside this aggregate (this is called Consistency Boundary).

Objects within the Aggregate can reference other Aggregate roots via their globally unique identifier (id). Avoid holding a direct object reference.

Try to avoid aggregates that are too big, this can lead to performance and maintaining problems.

In summary, if you combine multiple related entities and value objects inside one root Entity, this root Entity becomes an **Aggregate Root**, and this cluster of related entities and value objects becomes an **Aggregate**.

Example code:
- [aggregate-root.base.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/libs/ddd/aggregate-root.base.ts) - abstract base class.
- [user.entity.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/user.entity.ts) - aggregates are just entities that have to follow a set of specific rules described above.


### Domain Events

Domain Event indicates that something happened in a domain that you want other parts of the same domain (**in the same process**) to be aware of.

Domain events are just messages pushed to an in-memory Domain Event dispatcher.

For example, if a user buys something, you may want to:
- Update his shopping cart;
- Withdraw money from his wallet;
- Create a new shipping order;
- Perform other domain operations that are not a concern of an aggregate that executes a "buy" command.

If executing a command requires additional domain rules to be run on one or more additional aggregates, you can design and implement those side effects to be triggered by Domain Events. Propagation of state changes across multiple aggregates within the same domain model can be performed by subscribing to a concrete Domain Event and creating as many event handlers as needed. 

Domain Events may be useful for creating an audit log to track all changes to important entities by saving each event to the database.

All changes caused by Domain Events across multiple aggregates in a single process can be saved in a single database transaction. 

Example code:

- [user-created.domain-event.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/domain/events/user-created.domain-event.ts) - simple object that holds data related to published event.
- [create-wallet-when-user-is-created.domain-event-handler.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/wallet/application/event-handlers/create-wallet-when-user-is-created.domain-event-handler.ts) - this is an example of Domain Event Handler that executes some actions when a domain event is raised (in this case, when user is created it also creates a wallet for that user).
- [sql-repository.base.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/libs/db/sql-repository.base.ts) - repository publishes all domain events for execution when it persists changes to an aggregate.
- [create-user.service.ts](https://github.com/sairyss/domain-driven-hexagon/blob/master/src/modules/user/commands/create-user/create-user.service.ts) - in a service we execute a global transaction to make sure all the changes done by Domain Events across the application are stored atomically (all or nothing).


### Integration Events

Integration Events are events sent to external process (microservices, external APIs).

Integration Events usually should be published only after all Domain Events finished executing and saving all changes to the database.

To handle integration events you may need an external message broker / event bus like RabbitMQ or Kafka together with patterns like Transactional outbox, Change Data Capture, Sagas or a Process Manager to maintain eventual consistency.
