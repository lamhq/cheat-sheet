# Domain-Driven Hexagon

## Introduction

This architecture combines several patterns and styles:
- [Domain-Driven Design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design)
- [Hexagonal Architecture](https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)) (Ports and Adapters)
- [Secure by Design](https://www.manning.com/books/secure-by-design)
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [SOLID Principles](https://en.wikipedia.org/wiki/SOLID)


## Pros & Cons

**Pros**:
- Framework-agnostic: external frameworks, DBs, and services can be swapped with minimal changes.
- Secure: security principles are integrated into the design.
- Clear separation of concerns: teams can work independently.
- Testable & Scalable: adding features is easier and remains manageable.

**Cons**:
- Sophisticated architecture. Requires experienced architects to avoid misuse and technical debt.
- Added up-front complexity: more boilerplate, layers, and mappings.
- Not recommended for small/CRUD apps with little business logic.


## Use cases

Suitable for applications with complex business logic.

> [!CAUTION]
> Not recommended for simple CRUD apps that mainly map the database to a client; use [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) instead.


## Data Flow

![](https://github.com/Sairyss/domain-driven-hexagon/blob/master/assets/images/DomainDrivenHexagon.png?raw=true)

Data flow (left â†’ right):
1. **Request/CLI command/event** arrives as a plain **DTO** to a **Controller**.
2. **Controller** maps the DTO to a **Command/Query object** and calls an Application service.
3. **Application service** runs business logic using **domain services** and **entities/aggregates**, and calls ports to reach infrastructure.
4. **Infrastructure layer** maps data, persists/retrieves data, calls external APIs/brokers via **adapters**, and maps results back for the domain.
5. Application service returns results to the **Controller**.
6. **Controller** returns data to the user or to a presenter/view.

Each layer owns its logic and follows the Single Responsibility Principle. Different projects may use fewer or additional layers.


## Modules

The codebase is organized into small, independent modules that reflect domain concepts.

Each module lives in its own folder and contains related use cases.

**Benefits**:
- Refactor internals without affecting other modules (public interface isolation).
- Easier to split into a microservice when bounded contexts are well defined.

**Best practices to reduce coupling**:
- Keep module interactions minimal; prefer small, explicit interfaces.
- Move shared logic to common utilities rather than creating cross-module dependencies.
- Avoid importing another module's internals; use a [mediator](https://en.wikipedia.org/wiki/Mediator_pattern#:~:text=In%20software%20engineering%2C%20the%20mediator,often%20consist%20of%20many%20classes.) or a public [facade](https://en.wikipedia.org/wiki/Facade_pattern).
- Prefer message-based communication (command bus or events) when modules need to coordinate.

Each module consists of layers:
- Application
- Domain
- Interface Adapters
- Infrastructure


## Architecture Best Practices

- Choose patterns that fit your project's needs; avoid overengineering.
- Follow the YAGNI principle: don't add features or patterns before they are needed.
- Evaluate the cost vs benefit before introducing a pattern or abstraction.


## References

- [Sairyss / domain-driven-hexagon](https://github.com/Sairyss/domain-driven-hexagon)