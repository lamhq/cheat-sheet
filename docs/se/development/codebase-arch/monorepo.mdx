# Monorepo

A monorepo is a single repository containing multiple distinct projects, with well-defined relationships.

Monorepos are used by tech giants like Google, Meta(Facebook), Microsoft, Uber.


## Use cases

- **Tightly Coupled Projects**: A monorepo allows for atomic commits, keeping related projects like a frontend and backend in sync with a single update.
- **Significant Code Sharing**: It simplifies code sharing, as all projects can easily access common libraries and components from a single location.
- **Sharing Tooling and Conventions**: when consistent coding standards, build tools, and CI/CD pipelines across all projects are required.


## Benefits

- **Atomic Commits & Refactoring**. Developers can make sweeping changes across multiple projects in a single commit, which simplifies large-scale refactoring.
- **No overhead to create new projects**. New projects can be created with minimal setup, using the existing CI setup. No need to publish versioned packages if all consumers are in the same repo.
- **One version of everything**. No need to worry about incompatibilities. Easier to coordinate releases and dependencies.
- **Unified Visibility & Collaboration**. Allow organizing related applications and packages in a single repository
- **Simplified Dependency Management**. Easily share code and dependencies
- **Consistent Tooling & Standards**. Easier to enforce coding conventions, CI/CD pipelines, and development tools across all teams.
- **Streamlined Onboarding**: New developers only need to clone one repo to access the entire codebase, speeding up setup and understanding.


## Challenges

- **Performance Issues**: As a monorepo grows, operations like cloning, fetching, and running builds can become slow. Tools and infrastructure need to be optimized to handle the large scale.
- **Tooling Complexity**: The tools used for version control, building, and testing must be able to handle a large and complex codebase efficiently. This often requires custom or highly specialized tooling.
- **Access Control**: Managing access and permissions can be more complicated. Since all code is in one repository, it can be difficult to restrict access to specific projects without complex configurations.
- **Learning Curve**: New developers may face a steeper learning curve when navigating a vast codebase. Onboarding can require more time to understand the project structure and various interdependencies.


## Features

What monorepo tools should provide:

### Fast

1. **Local task orchestration**: The ability to run tasks in the correct order and in parallel.
2. **Local computation caching**: The ability to store and replay file and process output of tasks. On the same machine, you will never build or test the same thing twice.
3. **Distributed computation caching**: The ability to share cache artifacts across different environments. This means that your whole organisation, including CI agents, will never build or test the same thing twice.
4. **Distributed task execution**: The ability to distribute a command across many machines
5. **Transparent remote execution**: The ability to execute any command on multiple machines while developing locally
6. **Detecting affected projects/packages**: Determine what might be affected by a change, to run only build/test affected projects.

### Understandable

1. **Workspace analysis**: The ability to understand the project graph of the workspace without extra configuration.
2. **Dependency graph visualization**: Visualize dependency relationships between projects and/or tasks.

### Manageable

1. **Source code sharing**: Facilitates sharing of discrete pieces of source code.
2. **Consistent tooling**: get a consistent experience regardless of what you use to develop your projects: different JavaScript frameworks, Go, Rust, Java, etc.
3. **Code generation**: Native support for generating code
4. **Project constraints and visibility**: Supports definition of rules to constrain dependency relationships within the repo. For instance, developers can mark some projects as private to their team so no one else can depend on them. Developers can also mark projects based on the technology used (e.g., React or Nest.js) and make sure that backend projects don't import frontend ones.