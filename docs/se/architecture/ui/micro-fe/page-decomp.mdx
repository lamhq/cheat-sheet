# Page-Based Decomposition

## Overview

The web application is divided into distinct applications, each responsible for rendering pages belong to its own feature.

- The decomposition is done at the page level.
- A shell app loads the correct Microfrontend based on the route prefix.
- Each Microfrontend is responsible for its own routing, logic, and rendering for its page.

For example, consider a web app with multiple pages:
- `/products/*` → Product Catalog App
- `/categories/*/products` → Product Catalog App
- `/cart/*` → Shopping Cart App
- `/checkout/*` → Checkout App


## Benefits

- **Clear ownership**: Each team owns a full page, making development and deployment easier.
- **Simplified Integration**: there's less need for deep UI coordination when working with pages.
- **Scalability**: Easier to scale development across large teams or organizations.
- **Isolation**: Fewer cross-team dependencies; easier to test and maintain.


## Challenges

- **Limited composition**: Harder to mix UI from multiple apps on the same page (for example, a dashboard).
- **Redundant code**: Shared widgets may be duplicated across pages (tag list, search bar, etc).


## Where to Use It?

- Large applications with clearly separated features.
- Organizations with multiple teams working on different distinct parts of the app.


## Structure

### Microfrontend

1. Each **Microfrontend** is responsible for rendering its own pages, providers, components, and other application-specific elements.  
2. It exposes a `render()` function that handles mounting the micro frontend to the DOM.  

```js title="marketing/src/bootstrap.js"
export function render(element, options) {
  const root = createRoot(element);
  root.render(<App {...options} />);
}
```
- `element`: The DOM node where the Microfrontend will be injected.
- `options`: Optional configuration passed to the Microfrontend for rendering.


### Shell App

1. For each Microfrontends, the shell app imports the `render()` function and invokes it to integrate the Microfrontends into its layout.
2. How the shell app import the `render()` function will be explained in the next section.

```js title="shell/src/bootstrap.js"
import { render } from '...';

export default function MarketingApp() {
  const ref = useRef(null);

  // Render the microfrontend once
  useEffect(() => {
    render(ref.current, options);
  }, []);

  return <div ref={ref} />;
}
```


## Integration

This guide uses [run-time integration](./integration.mdx#run-time-integration).

### Microfrontend

1. The Microfrontend exposes the module containing the `render()` function using **Webpack Module Federation** plugin.  
2. During the build process, Webpack bundles the module into a dedicated JavaScript file: `remoteEntry.js`.  
3. The `remoteEntry.js` file is then hosted on a web server and made accessible via a URL.

```js title="marketing/webpack.prod.js"
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'marketing',
      filename: 'remoteEntry.js',
      exposes: {
        './MarketingApp': './src/bootstrap',
      },
    }),
  ],
};
```


### Shell App

1. The shell application need to know the location of the `remoteEntry.js` file of each Microfrontend.  
2. It uses **Webpack Module Federation** plugin to dynamically load the Microfrontend at runtime.

```js title="shell/webpack.prod.js"
const domain = process.env.PRODUCTION_DOMAIN;

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        marketing: `marketing@https://${domain}/marketing/latest/remoteEntry.js`,
        auth: `auth@https://${domain}/auth/latest/remoteEntry.js`,
      },
    }),
  ],
};
```

```js title="shell/src/bootstrap.js"
import { render } from 'marketing/MarketingApp';

export default function MarketingApp() {
  const ref = useRef(null);

  // Render the microfrontend once
  useEffect(() => {
    render(ref.current, options);
  }, []);

  return <div ref={ref} />;
}
```


## Local Development

### Microfrontend

1. Launch the Microfrontend locally using Webpack Dev Server.
2. In the Webpack entry point (`src/index/js`), import the `bootstrap` module.
3. Within the `bootstrap` module, invoke the `render()` function directly when running in development mode.

```js title="marketing/webpack.dev.js"
module.exports = {
  mode: 'development',
  output: {
    publicPath: 'http://localhost:8082/',
  },
  devServer: {
    port: 8082,
  },
  plugins: [
    new ModuleFederationPlugin({
      // existing config...
    }),
    new HtmlWebpackPlugin({
      template: './public/index.html',
    }),
  ],
};
```

```js title="marketing/src/index.js"
import('./bootstrap');
```

```js title="marketing/src/bootstrap.js"
// If we are in development and in isolation,
// call render immediately
if (process.env.NODE_ENV === 'development') {
  const devRoot = document.querySelector('#marketing-dev-root');
  if (devRoot) {
    render(devRoot, defaultOptions);
  }
}
```

> [!CAUTION]
> It's required to call `import('./bootstrap')` in the entry point script to ensure that shared dependencies are available when the `bootstrap` module is loaded in the browser.


### Shell App

1. Configure **Webpack Module Federation** plugin with the local addresses of all Microfrontends
2. Launch all Microfrontends before starting the shell app

```js title="shell/webpack.dev.js"
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        marketing: `marketing@http://localhost:8082/remoteEntry.js`,
        auth: `auth@http://localhost:8083/remoteEntry.js`,
      },
    }),
  ],
};
```


## Communication

Interaction between the shell application and its microfrontends is handled through **callback functions**, which are passed as arguments to—and return values from—the `render()` function.

### Microfrontend

To **send data back to the shell app**, the `render()` function can:
- Return initial data directly when invoked.
- Accept a callback function as a parameter, and invoke it whenever the internal data changes.

```js title="microfrontend.js"
export function render(onDataChange) {
  const initialData = { status: 'ready', timestamp: Date.now() };

  // Send initial data back to shell app
  // (Pattern 1: return initial data directly)
  if (typeof onDataChange !== 'function') {
    return initialData;
  }

  // Simulate internal state change after 2 seconds
  setTimeout(() => {
    const updatedData = { status: 'updated', timestamp: Date.now() };
    onDataChange(updatedData); // (Pattern 2: invoke callback on change)
  }, 2000);

  return initialData;
}
```

```js title="shell-app.js"
import { render } from './microfrontend.js';

// Provide a callback to receive updates
const initialData = render((data) => {
  console.log('Shell app received updated data:', data);
});

console.log('Shell app received initial data:', initialData);
```

To **receive data from the shell app**, the `render()` function can:
- Accept initial data as an argument during invocation.
- Return a callback function that receives updated data from the shell app whenever changes occur.

```js title="microfrontend.js"
export function render(initialData) {
  let internalState = initialData || {};

  console.log('Microfrontend received initial data:', internalState);

  // Return a callback for the shell app to send updates later
  return function receiveUpdate(newData) {
    internalState = { ...internalState, ...newData };
    console.log('Microfrontend received updated data:', internalState);
  };
}
```

```js title="shell-app.js"
import { render } from './microfrontend.js';

// Send initial data during render
const updateCallback = render({ user: 'lac', theme: 'dark' });

// Later, push updated data to microfrontend
setTimeout(() => {
  updateCallback({ theme: 'light', notifications: true });
}, 2000);
```


### Shell App

Similar to the microfrontend, the shell app can send and receive data from the microfrontend.
