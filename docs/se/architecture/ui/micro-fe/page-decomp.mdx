# Page-Based Decomposition

## Overview

The web application is divided into distinct applications, each responsible for rendering pages belong to its own feature.

- The decomposition is done at the page level.
- A shell app loads the correct Microfrontend based on the route prefix.
- Each Microfrontend is responsible for its own routing, logic, and rendering for its page.

For example, consider a web app with multiple pages:
- `/products/*` → Product Catalog App
- `/categories/*/products` → Product Catalog App
- `/cart/*` → Shopping Cart App
- `/checkout/*` → Checkout App


## Benefits

- **Clear ownership**: Each team owns a full page, making development and deployment easier.
- **Simplified Integration**: there's less need for deep UI coordination when working with pages.
- **Scalability**: Easier to scale development across large teams or organizations.
- **Isolation**: Fewer cross-team dependencies; easier to test and maintain.


## Challenges

- **Limited composition**: Harder to mix UI from multiple apps on the same page (for example, a dashboard).
- **Redundant code**: Shared widgets may be duplicated across pages (tag list, search bar, etc).


## Where to Use It?

- Large applications with clearly separated features.
- Organizations with multiple teams working on different distinct parts of the app.


## Structure

### Microfrontend

1. Each **Microfrontend** is responsible for rendering its own pages, providers, components, and other application-specific elements.  
2. It exposes a `render()` function that handles mounting the micro frontend to the DOM.  

```js title="marketing/src/bootstrap.js"
export function render(element, options) {
  const root = createRoot(element);
  root.render(<App {...options} />);
}
```
- `element`: The DOM node where the Microfrontend will be injected.
- `options`: Optional configuration passed to the Microfrontend for rendering.


### Shell App

1. For each Microfrontends, the shell app imports the `render()` function and invokes it to integrate the Microfrontends into its layout.
2. How the shell app import the `render()` function will be explained in the next section.

```js title="shell/src/bootstrap.js"
import { render } from '...';

export default function MarketingApp() {
  const ref = useRef(null);

  // Render the microfrontend once
  useEffect(() => {
    render(ref.current, options);
  }, []);

  return <div ref={ref} />;
}
```


## Integration

This guide uses [run-time integration](./integration.mdx#run-time-integration).

### Microfrontend

1. The micro frontend exposes the `bootstrap` module containing the `render()` function to the web using the **Webpack Module Federation** plugin.  
2. During the build process, Webpack bundles the `bootstrap` module into a dedicated JavaScript file.  
3. This JavaScript file is then hosted on a web server and made accessible via a URL:

```
https://{domain}/{app-name}/{version}/remoteEntry.js
```
- `{domain}`: The domain where the JavaScript file is deployed.
- `{app-name}`: Identifier for the microfrontend (e.g., "marketing").
- `{version}`: Specific version of the microfrontend, allowing the shell app to load different versions as needed.

```js title="marketing/webpack.prod.js"
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'marketing',
      filename: 'remoteEntry.js',
      exposes: {
        './MarketingApp': './src/bootstrap',
      },
    }),
  ],
};
```


### Shell App

1. The shell application obtains the URL of the JavaScript file containing the `bootstrap` module from the Microfrontend and uses it to configure the **Webpack Module Federation** plugin.  
2. Leveraging this plugin, the shell app can dynamically load the micro frontend at runtime, using the same import syntax as it would for a standard module.

```js title="shell/webpack.prod.js"
const domain = process.env.PRODUCTION_DOMAIN;

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        marketing: `marketing@https://${domain}/marketing/latest/remoteEntry.js`,
        auth: `auth@https://${domain}/auth/latest/remoteEntry.js`,
      },
    }),
  ],
};
```

```js title="shell/src/bootstrap.js"
import { render } from 'marketing/MarketingApp';

export default function MarketingApp() {
  const ref = useRef(null);

  // Render the microfrontend once
  useEffect(() => {
    render(ref.current, options);
  }, []);

  return <div ref={ref} />;
}
```


## Local Development

### Microfrontend

1. Launch the Microfrontend locally using Webpack Dev Server.
2. Use the **HtmlWebpackPlugin** to automatically insert the bundled script into the HTML file.
3. In the Webpack entry point, import the `bootstrap` module.
4. Within the `bootstrap` module, invoke the `render()` function directly when running in development mode.

```js title="marketing/webpack.dev.js"
module.exports = {
  mode: 'development',
  output: {
    publicPath: 'http://localhost:8082/',
  },
  devServer: {
    port: 8082,
  },
  plugins: [
    new ModuleFederationPlugin({
      // existing config...
    }),
    new HtmlWebpackPlugin({
      template: './public/index.html',
    }),
  ],
};
```

```js title="marketing/src/index.js"
import('./bootstrap');
```

```js title="marketing/src/bootstrap.js"
// If we are in development and in isolation,
// call render immediately
if (process.env.NODE_ENV === 'development') {
  const devRoot = document.querySelector('#marketing-dev-root');
  if (devRoot) {
    render(devRoot, defaultOptions);
  }
}
```

> [!CAUTION]
> It's required to call `import('./bootstrap')` in the entry point script to ensure that shared dependencies are available when the `bootstrap` module is loaded in the browser.


### Shell App
