# Widget-Based Decomposition

## Overview

Widget-Based Decomposition divides UI into smaller, independent **widgets**, each responsible for specific functionality.

- The decomposition is done at the widget level.
- There's a shell app that manages navigation and defines which widgets appear on the UI.
- A widget may interact with backend microservices.

Example: Spotify uses separate widgets to display playlists, artists, and user-following details.


## Implementation

With simple website, including widgets as HTML fragments using client-side or server-side templating.

With widgets that contain a lots of Javascript, ensure they are packaged in a way that donâ€™t conflict with others (this could end up with a lot of duplication between dependencies and increase page load size).

Avoiding iFrames, they have issues related to sizing and communication difficulties between different parts of the UI.

Communication between widgets is achieved using Browser custom event, similar to Event-Driven Communication in Microservices.


## Benefits

- Allows multiple stream-aligned teams to contribute to the same UI.
- It's more flexible than **page-based decomposition**, widgets from different teams can appear on the same page.
- It enables [frontend teams](./team-topologies.mdx#dedicated-frontend-teams) to provide reusable widgets for stream-aligned teams.


## Challenges

- **Complex orchestration**: Requires a complex shell app to manage loading, rendering, and communication.
- **Performance overhead**: Multiple bundles and runtime coordination can slow things down.

Regarding SPAs:
- Require setting up the separate bundling for each widget (one-time cost)
- Page size can inflate easily when updating a widget's dependencies. Be sure to put automated alert if
the page weight goes above a threshold.
