# Monolith

When all functionality in a system must be deployed together, it is considered a monolith.

## Single-Process Monolith

A single-process monolith is a system where all of the code is deployed as a single process

The process may have multiple instances for robustness or scaling reasons.

The classic single-process monolithic architecture can make sense for smaller applications or teams. However, as the application grows, it can become harder to maintain and scale.

![](./monolith/single-monolith.drawio.svg)


## The Modular Monolith

The modular monolith is a variation of the single-process monolith where the single process consists of separate modules.

Each module can be worked on independently, but all modules still need to be combined together for deployment.

The modular monolith can be a good choice for organizations if module boundaries are well defined, allowing for parallel work and simpler deployment topology compared to microservice architecture.

> Shopify is an example of an organization that successfully uses the modular monolith approach instead of microservices

![](./monolith/modular-monolith.drawio.svg)

One challenge of the modular monolith is that the database tends to lack decomposition, which could pose difficulties if you want to pull apart the monolith in the future.

Some teams attempt to address this challenge by decomposing the database along the same lines as the modules.

![](./monolith/modular-mono-decomp-db.drawio.svg)


## The Distributed Monolith

A distributed monolith is a system that consists of multiple services but must be deployed together.

A distributed monolith may meet the definition of a Service-Oriented Architecture (SOA), but often fails to deliver the promised benefits of SOA.

Distributed monoliths have the disadvantages of both a distributed system and a single-process monolith, without enough of the advantages of either.

Distributed monoliths typically arise from architectures that lack focus on concepts like information hiding and cohesion of business functionality.

Highly coupled architectures in distributed monoliths can lead to changes spreading across service boundaries and even even minor, localized updates can break other parts of the system.


## Advantages

Simpler deployment topology and avoiding pitfalls of distributed systems.

Simplify developer workflows and activities like monitoring, troubleshooting, and end-to-end testing.

Code reuse is easier within a monolith compared to a distributed system.

A monolithic architecture is a valid and sensible default choice as an architectural style.


## Disadvantages

### Delivery contention

Occur when different teams or developers need to make changes to the same parts of the codebase, can cause conflicts and delays in deployment. 

When multiple teams are involved, it's difficult to define clear **ownership** boundaries, that leads to confusion around ownership and decision-making.

The need for coordinated deployments can lead to "**deployment trains**", where teams must wait for each other to deploy their changes, causing delays.

> [!TIP]
> Having a monolith or microservice architecture does not guarantee the presence or absence of delivery contention. However, a microservice architecture provides more concrete boundaries for ownership, offering greater flexibility in reducing this problem.


### Scalability Limitations

Scaling requires replicating the entire application, which can be resource-intensive and inefficient, especially when only specific components experience high demand.


### Maintenance Challenges

As the codebase grows, understanding and modifying the system becomes increasingly difficult, leading to longer development cycles.


### Lack of Flexibility

Updating a single component often requires redeploying the entire application, increasing the risk of downtime and unintended errors.


### Reliability Risks

A failure in any part of the application can potentially bring down the entire system, as everything runs within a single process.


### Technology Lock-In

All components must often use the same technology stack, limiting the ability to adopt more suitable or innovative solutions for specific parts of the application.