# Event-Driven Architecture

## Overview

Event-Driven Architectures (EDA) is an architecture paradigm where the flow and actions within a system are determined by the occurrence of specific events.

EDA use asynchronous communication, leads to loosely coupled components.


## Components

An Event is an immutable statement of a fact or a change., such as `OrderPlaced` or `UserRegistered`.

In an Event-Driven Architecture, we have three components:

- Event Emitters/Producer: Component that creates and publishes events; it shouldn't have knowledge of downstream consumers of the events
- Event Consumer: Component that consumes and processes based on events
- Message Broker: Accepts events and either pushes to (or is pulled from by) consumers


## Benefits

1. **Decoupling**. Services don't need to know about each other's API. All messages are exchanged asynchronously.
2. **Scalability**. Services can scale independently. More services can be added to the system without any changes.
3. **Resilience**. If a Consumer down, events can be queued and retained for later processing.
4. **Responsiveness**. The publisher can quickly fire an event and move on, not waiting for downstream processing.
5. **Support Real Time Stream Analysis**. EDA allows analyze streams of data, detect patterns, and act upon them in real time.


## Challenges

1. **Single point of failure**. The broker can be a single point of failure if not made highly available.
2. **Debugging & Tracing Distributed Flows**. Understand the E2E flow of an operation triggered by an event can be complex.
3. **Eventual Consistency** Data consistency across services is achieved over time, not instantaneously. UX must be designed to handle this.
4. **Idempotency**. Subscribers must often be designed to handle duplicate messages gracefully.


## Patterns

There are several event-driven architecture patterns:
1. [Event sourcing](../system-design/patterns/event-sourcing.mdx): when every single change of state is a submitted event such that the events make up the state of the whole system
2. [CQRS](../system-design/patterns/cqrs.mdx): a pattern to segregate reading and writing. The informational events are segregated from the actual commands to make changes
3. Event notification: it's a notification that something has occurred
4. Event-carried state transfer: similar to Event Notification but also contains the state


## Communication types

### Pub/Sub

Allows a producer to publish to specific topics without a notion of what is subscribed.

Consumers can subscribe to that particular event topic.

Amazon SNS is the AWS-managed service for this.


### Point-to-point

When a producer will send a message for a particular consumer, it might push the event to a queue.

The consumer can then pull from that queue.


### Streaming

Similar to a queue system.

Data is continuously pushed to a stream and consumers need to pull that data.


## Choreographed vs. orchestration

**Choreography** is when the events flow through different services in a system without a higher level of control.

*For example, an `OrderPlaced` event then causes an `OrderPicked` and packed event, which itself causes an `OrderShipped` event.*

**Orchestration** is when there is a central system controlling the interactions.

*You may design a single order orchestrator that calls each service in the right order and ensures each action is taken as appropriate.*


## Use Cases

- Microservices
- E-commerce systems
- Real-time monitoring
- Social networks
- Supply chain management
- Infrastructure automation
