# Widget-Based Decomposition

## Overview

Widget-Based Decomposition divides UI into smaller, independent **widgets**, each responsible for specific functionality.

It allows different teams to work on separate components without disrupting the overall system.


## How it work?

Each widget in a graphical interface functions independently.

A widget may interact with backend microservices.

There is a central application that manages navigation and defines which widgets appear on the UI.

Example: Spotify uses separate widgets to display playlists, artists, and user-following details.


## Implementation

With simple website, including widgets as HTML fragments using client-side or server-side templating.

With widgets that contain a lots of Javascript, ensure they are packaged in a way that donâ€™t conflict with others (this could end up with a lot of duplication between dependencies and increase page load size).

Avoiding iFrames, they have issues related to sizing and communication difficulties between different parts of the UI.

Communication between widgets is achieved using Browser custom event, similar to Event-Driven Communication in Microservices.


## Advantages

Allows multiple stream-aligned teams to contribute to the same UI.

It's more flexible than **page-based decomposition**, widgets from different teams can appear on the same page.

It enables **enabling teams** to provide reusable widgets for stream-aligned teams.

Useful if you are building a rich web-based user interface, or breaking an SPA into micro frontend.


## Concerns

Regarding SPAs:
- Require setting up the separate bundling for each widget (one-time cost)
- Page size can inflate easily when updating a widget's dependencies. Be sure to put automated alert if
the page weight goes above a threshold.
