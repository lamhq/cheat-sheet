# API Gateway

## Overview

An **API gateway** is a server that acts as a single entry point for all external requests to internal microservices.

Instead of clients needing to know and communicate with dozens of services, they just talk to the gateway.

Uses Layer 7 routing (application-level) to intelligently forward requests.

![](https://jstobigdata.com/wp-content/uploads/2021/01/Single_Api_Gateway.svg)


## Key Functions

- Routing. Directs requests to the correct microservice.
- Authentication & Authorization
- SSL Certificate validation
- Rate limiting
- Logging & Monitoring
- Protocol Translation: Converts client-friendly formats (e.g., REST) into internal formats (e.g., gRPC).


## Benefits

- **Client Decoupling**. Clients don't need to know the internal structure of microservices. This simplifies backend refactoring and evolution.
- **Centralized Cross-Cutting Concerns**. Common tasks like authentication, logging, rate limiting, and monitoring can be handled in one place.
- **Security and Access Management**: With a single entry point, it's easier to secure, monitor, and manage access to backend services.


## Challenges

- **Potential Bottleneck**. All traffic flows through the gateway. If it's not designed to scale well, it can slow down the entire system.
- **Single Point of Failure**. If the gateway crashes, clients lose access to all backend services. To avoid this, it must be deployed in a highly available setup.
- **Operational Overhead**. The gateway itself is another component that needs to be developed, configured, deployed, and maintained.
- **Risk of Becoming a "Fat API Gateway"**. Putting too much business logic into the gateway turns it into a complex monolith, defeating the purpose of microservices. It should stick to gateway-specific tasks only.
- **Added Latency**. Every request now has an extra network hop through the gateway. While aggregation can reduce perceived latency, the gateway must be optimized to keep actual latency low.


## What to Avoid

1. Using API gateways for **call aggregation**. It is better handled by GraphQL or Backend-for-Frontend (BFF) patterns.
2. Placing too much behavior in API gateways leads to restricted control and more complicated change management.
3. Using API gateways for inter-microservice calls. It can introduce additional network hops and increase latency. Service meshes are much better placed to solve this problem.
