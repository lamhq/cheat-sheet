# Sagas

## Overview

A Saga is a sequence of local transactions distributed across multiple microservices.

Each local transaction updates data within a single service (using its own ACID).

When a local transaction completes, it triggers the next local transaction

If any local transaction fails: The saga executes compensating transactions to undo the work done by preceding successful local transactions.

The Saga pattern is crucial for managing long-running, multi-step business transactions in a distributed system.

Unlike [two-phase commit](./dtx.mdx#two-phase-commit), sagas coordinates multiple state changes without the need for locking resources.


## Implementations

There're two styles of saga implementation: **Orchestration-based Saga** and **Choreography-based Saga**.

### Orchestration-based Saga

Orchestration-based Saga use a central orchestrator service to coordinate and manage the individual sagas or microservices that make up a transaction.

The orchestrator is responsible for executing the transaction and ensuring that each step are performed in the correct order.

If any of the sagas fail to complete their step, the orchestrator can use the compensating transactions to roll back the changes and restore the system to its original state.

Orchestration-based Saga make heavy use of request-driven interactions.

**Benefits:**
1. **Easy to understand and maintained**.
   - The business process is clearly modeled in one place.
   - Easier to debug the system, add or modify transactions

**Challenges:**
1. The orchestrator tightly couples with all services
2. The orchestrator can become a single point of failure or bottlenecks (if heavily loaded).

**Where to use?**:
- Good for complex workflows with a lots of steps.
- Ideal when a single team owns the entire workflow.


### Choreography-based Saga

Each microservice communicates with the other microservices by exchanging events using a message broker.

Each microservices run its own local transaction, publishes events to trigger transaction in the next service.

If a service encountered an error, it could publish a failure event to the message broker. The previous services woud execute a compensating transaction to undo the changes.

Choreography-based Saga makes extensive use of events.

**Benefits**:
1. **Decentralized and flexible**. Services are independent, only reacting to received events, reducing domain coupling.
2. **Avoid Single Point of Failure**. Since there is no orchestrator, responsibilities are distributed across the saga participants.

**Challenges**:
1. **Complex to manage**. Adding new steps into the workflow may cause confusing.
2. **Hard to track & debug**. Understanding the overall business process requires piecing together individual service behaviors.
   - **Correlation ID** can be passed in all saga-related events to track the state of the workflow. When a service reacts to an event, it extracts and passing the ID to subsequent events.
3. **Risk of cyclic events**. Poorly designed event flows can lead to infinite loops where services continuously trigger each other.

**Where to use?**
- Good for simple workflows that don't require too much steps.
- Ideal when workflow involves multiple teams.


## Compensating Transaction pattern

To roll back in a saga, a compensating transaction is needed to undo previous changes.

A compensating transaction reverses the effects of a previously successfully completed local transaction within a Saga:
- It's the "undo" operation for a specific step in a distributed business process.
- It's triggered when a subsequent step in a Saga fails, requiring the overall business operation to be rolled back.

**Goal**: To ensure that if the entire Saga cannot complete, the system is returned to a consistent state (from a business perspective)

The compensating transaction don't necessarily restore the exact state like a database rollback does, it might perform business operations that semantically negate the effect of the original transaction.
- *For example, if an order confirmation email was sent, a rollback can’t undo it. Instead, a **compensating transaction** sends a second email informing the customer of the cancellation. We also keep a record of aborted orders in the system.*

### Characteristics

1. **Specific to an Operation**. Each local transaction in a Saga should have a corresponding compensating transaction
2. **Idempotent by Design**. Executing Compensating transactions multiple times should have the same effect as executing it once.
3. **Can Also Fail**. A compensating transaction is also a distributed operation and could potentially fail. Failures need to be handled (through retries or manual intervention).
4. **Eventual Consistency**. The process of compensation brings the system back to a consistent state eventually
5. **Data for Compensation**. A compensating transaction often need information from original transaction to perform its operation.


## Minimizing rollbacks

You can simplify rollback operations by pulling forward steps that are most likely to fail, reducing the need for triggering complex compensating transactions.

For example, imagine an online store where a customer places an order, triggering multiple steps:
1. **Charge payment**
2. **Check inventory**
3. **Reserve shipping slot**

If payment fails, rolling back inventory and shipping reservations would be needed. Instead, by **checking inventory first**, you avoid unnecessary rollback if an item is out of stock, reducing compensating transactions.


## Fail-forward situations

Some failures may require a rollback (fail backward), others may be fail forward.

*For example, when processing an order, if for whatever reason we can’t dispatch the package, it seems very odd to roll the whole order back. Instead, we’d probably just retry the dispatch, and if that fails, we’d require human intervention to resolve the situation.*


## Sagas vs. Distributed Transactions

Modeling business processes as sagas avoids distributed transaction challenges and enhances clarity for developers by modeling business processes explicitly and reducing tight coupling between services.