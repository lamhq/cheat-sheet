# Sagas

## Overview

A Saga is a sequence of local transactions distributed across multiple microservices.

Each local transaction updates data within a single service (using its own ACID).

When a local transaction completes, it triggers the next local transaction

If any local transaction fails: The saga executes compensating transactions to undo the work done by preceding successful local transactions.

The Saga pattern is crucial for managing long-running, multi-step business transactions in a distributed system.

Unlike [two-phase commit](./dtx.mdx#two-phase-commit), sagas coordinates multiple state changes without the need for locking resources.


## Implementations

There're two styles of saga implementation: **Orchestration-based Saga** and **Choreography-based Saga**.

### Orchestration-based Saga

Orchestration-based Saga use a central orchestrator service to coordinate and manage the individual sagas or microservices that make up a transaction.

The orchestrator is responsible for executing the transaction and ensuring that each step are performed in the correct order.

If any of the sagas fail to complete their step, the orchestrator can use the compensating transactions to roll back the changes and restore the system to its original state.

Orchestration-based Saga make heavy use of request-driven interactions.

**Benefits:**
1. **Easy to understand and maintained**.
   - The business process is clearly modeled in one place.
   - Easier to debug the system, add or modify transactions

**Challenges:**
1. The orchestrator tightly couples with all services
2. The orchestrator can become a single point of failure or bottlenecks (if heavily loaded).

**Where to use?**:
- Good for complex workflows with a lots of steps.
- Ideal when a single team owns the entire workflow.


### Choreography-based Saga

Each microservice communicates with the other microservices by exchanging events using a message broker.

Each microservices run its own local transaction, publishes events to trigger transaction in the next service.

If a service encountered an error, it could publish a failure event to the message broker. The previous services woud execute a compensating transaction to undo the changes.

Choreography-based Saga makes extensive use of events.

**Benefits**:
1. **Decentralized and flexible**. Services are independent, only reacting to received events, reducing domain coupling.
2. **Avoid Single Point of Failure**. Since there is no orchestrator, responsibilities are distributed across the saga participants.

**Challenges**:
1. **Complex to manage**. Adding new steps into the workflow may cause confusing.
2. **Hard to track & debug**. Understanding the overall business process requires piecing together individual service behaviors.
   - **Correlation ID** can be passed in all saga-related events to track the state of the workflow. When a service reacts to an event, it extracts and passing the ID to subsequent events.
3. **Risk of cyclic events**. Poorly designed event flows can lead to infinite loops where services continuously trigger each other.

**Where to use?**
- Good for simple workflows that don't require too much steps.
- Ideal when workflow involves multiple teams.


## No atomicity

Saga does not provide atomicity like traditional database transactions.

The saga itself isn't atomic. However, each step can still follow ACID rules if needed.


### Failure Recovery

Failures can be handled in two ways:

- **Backward recovery**: Rolls back failed transactions using compensating actions to undo previous changes.
- **Forward recovery**: Allows the system to to continue processing from the point of failure.


### Business failures

Saga allows us to recover from business failures, not technical failures.

> For example, if we try and take payment from the customer but the customer has insufficient funds, then this is a business failure that the saga should be expected to handle.
>
> On the other hand, if the Payment Gateway times out or throws a 500 Internal Service Error, then this is a technical failure that we need to handle separately.


## Saga rollbacks
To roll back in a saga, a **compensating transaction** is needed to undo previous changes.

A compensating transaction is a new transaction that reverts the changes made by the original transaction, but we can't make it as the original transaction didn’t occur.

Since full rollback isn’t always possible, compensating transactions are called semantic rollbacks.

It's important to persist rollback information in the system.

*For example, if an order confirmation email was sent, a rollback can’t undo it. Instead, a **compensating transaction** sends a second email informing the customer of the cancellation. We also keep a record of aborted orders in the system.*


## Minimizing rollbacks

You can simplify rollback operations by pulling forward steps that are most likely to fail, reducing the need for triggering complex compensating transactions.

For example, imagine an online store where a customer places an order, triggering multiple steps:
1. **Charge payment**
2. **Check inventory**
3. **Reserve shipping slot**

If payment fails, rolling back inventory and shipping reservations would be needed. Instead, by **checking inventory first**, you avoid unnecessary rollback if an item is out of stock, reducing compensating transactions.


## Fail-forward situations

Some failures may require a rollback (fail backward), others may be fail forward.

*For example, when processing an order, if for whatever reason we can’t dispatch the package, it seems very odd to roll the whole order back. Instead, we’d probably just retry the dispatch, and if that fails, we’d require human intervention to resolve the situation.*


## Sagas vs. Distributed Transactions

Modeling business processes as sagas avoids distributed transaction challenges and enhances clarity for developers by modeling business processes explicitly and reducing tight coupling between services.