# Resiliency

## Overview

Resilience refers to the ability of a system to withstand failures and recover gracefully without causing major disruptions to the overall application.

Microservices system is considered to be resilient, if it can continue to function effectively despite failures or disruptions.

This's important because in a distributed architecture, failures are inevitable due to network issues, service crashes, or hardware faults.


## Key Principles

Key Principles of Resilient Microservices:
- **Design for failure**: Assume things will go wrong and plan accordingly.
- **Graceful degradation**: If one service fails, others should still work.
- **Fault tolerance**: The system should continue operating even when parts of it fail.
- **Self-healing**: Services should restart or reroute automatically when issues occur.
- **Isolation**: Prevent cascading failures by isolating services (e.g., using bulkheads or circuit breakers).


## Patterns

Common resiliency patterns help systems stay responsive and stable even when parts of them fail:

- **Retry**: Automatically reattempt failed requests due to transient issues
- **Timeout**: Limit how long a service waits for a response to avoid hanging
- **Circuit Breaker**: Stop sending requests to a failing service to prevent overload
- **Bulkhead**: Isolate resources so one service’s failure doesn’t affect others
- **Fallback**: Provide alternative logic or default response when a service fails
- **Rate Limiter**: Control the number of requests to prevent overload
- **Health Check**: Monitor service status and trigger recovery mechanisms if needed
- **Fail Fast**: Immediately reject requests when a service is known to be down
- **Load Shedding**: Drop excess requests when the system is under heavy load
- **Dead Letter Queue**: Store failed messages for later inspection or reprocessing
- **Service Mesh Resilience**: Use tools like Istio or Linkerd to manage retries, timeouts, and circuit breakers at the network level
