# Data Partitioning

## Overview

Data Partitioning is the process of dividing a large database into smaller, more manageable and independent pieces called partitions.

Each partition can often be managed and accessed separately.

Goal: Distribute data to improve availability, scalability and performance

Often transparent to client applications (they see a single logical database)


## Benefits

1. **Performance**: Queries can be performed in parallel, on smaller dataset
2. **Availability**: Failure of one partition/server doesn't affect others
3. **Scalability**: we can scale database to store more data (horizontal scaling)
4. **Manageability**: Smaller partitions are easier to back up, index and maintain
5. **Security**: We can isolate sensitive data in specific partitions


## Challenges

1. **Increased Complexity**.
   - We need to route queries to the right shards
   - Make sure neither of the shards become too large
   - Backup and recovery become more difficult when dealing with multiple partitions.
2. **Expensive Cross-Partition Queries**. Querying data from all partitions can be resource-intensive and slow.  
3. **Difficulty Ensuring Uniqueness**. Maintaining unique constraints across partitions is more complex and error-prone.


## Types of Partitioning

### Horizontal Partitioning (Sharding)

Splits the table into rows.

Each partition has the same schema and contains a subset of the rows.

### Vertical Partitioning

Splits the table into columns.

Each partition contains a subset of the columns.

Frequently accessed columns are stored in one partition, while less frequently accessed columns are stored in another.

Benefit: improve performance of queries that often accessing only a subset of columns.

### Functional Partitioning (Domain/Context-Based)

Divides data based on how it's used by different business functions or bounded contexts within app

Data is segregated according to its usage domain

Aligns closely with how we decompose microservices by business capability or DDD subdomains

Example: Product data in one set of tables/schema, Order data in another, Customer data in yet another.

This is often a natural outcome of the Database-per-Service pattern & Polyglot Persistence
