# Back-of-the-envelope Calculation

## Overview

**Back-of-the-envelope Calculation** (BotE) is a technique used to quickly approximate values and make rough calculations using simple arithmetic and basic assumptions.

When you're designing a system, sometimes you need to estimate system capacity or performance requirements using a BotE calculation.

This method is particularly useful in scenarios where precise data isn't available or when a quick estimate is sufficient for decision-making.

Some concepts should be well understood:
- power of two (^2)
- latency numbers
- availability numbers


## Power of two

| Power | Approximate value | Full name  | Short name |
|-------|-------------------|------------|------------|
| 10    | 1 Thousand        | 1 Kilobyte | 1 KB       |
| 20    | 1 Million         | 1 Megabyte | 1 MB       |
| 30    | 1 Billion         | 1 Gigabyte | 1 GB       |
| 40    | 1 Trillion        | 1 Terabyte | 1 TB       |
| 50    | 1 Quadrillion     | 1 Petabyte | 1 PB       |


## Latency numbers

These numbers should give us an idea of the fastness and slowness of different computer operations.

| Operation name                          | Time                           |
|-----------------------------------------|--------------------------------|
| L1 cache reference                      | 0.5 ns                         |
| Branch mispredict                       | 5 ns                           |
| L2 cache reference                      | 7 ns                           |
| Mutex lock/unlock                       | 100 ns                         |
| Main memory reference                   | 100 ns                         |
| Compress 1K bytes with Zippy            | 10,000 ns = 10 Microsecond   |
| Send 2K bytes over 1 Gbps network       | 20,000 ns = 20 Microsecond   |
| Read 1 MB sequentially from memory      | 250,000 ns = 250 Microsecond |
| Round trip within the same datacenter   | 500,000 ns = 500 Microsecond |
| Disk seek                               | 10,000,000 ns = 10 ms          |
| Read 1 MB sequentially from the network | 10,000,000 ns = 10 ms          |
| Read 1 MB sequentially from disk        | 30,000,000 ns = 30 ms          |

Second > Milisecond > Microsecond > Nanosecond (ns) > Picosecond (ps)

Speed: CPU cache > RAM > Disk > Local network > Global Network.

Some things to notice:
- Avoid disk seeks if possible.
- Compress data before sending it over the internet if possible.
- Data centers are usually in different regions, and it takes time to send data between them.
- Global shared data is expensive. This is a fundamental limitation of distributed systems. The lock contention in shared heavily written objects kills performance as transactions become serialized and slow.
- Design your system in a way that can handle an increasing number of write operations as your application grows
- Optimize for low write contention (delays and conflicts when multiple processes try to write to the same resource simultaneously).
- Make writes as parallel as you can. Spreading out write operations to occur simultaneously rather than sequentially.


## Availability numbers

See [Availability](./quality-attributes/availability.mdx).


## Examples

### Estimate Twitter QPS and storage requirements

Assumptions:
- 300 million monthly active users.
- 50% of users use Twitter daily.
- Users post 2 tweets per day on average, 10% of tweets contain media.
- Data is stored for 5 years.

Query per second (QPS) estimate:
- Daily active users (DAU) = 300 million * 50% = 150 million
- Tweets QPS = 150 million * 2 tweets / 24 hour / 3600 seconds = ~3500
- Peek QPS = 2 * QPS = ~7000

Media storage estimate:
- Average tweet size: 1 MB
- Mediastorage: 150 million * 2 * 10% * 1MB = 30 TB per day
- 5-year media storage: 30TB * 365 * 5 = ~55 PB


## References

- [The System Design Primer](https://github.com/donnemartin/system-design-primer)
- [Latency Numbers Every Programmer Should Know](https://colin-scott.github.io/personal_website/research/interactive_latency.html).
