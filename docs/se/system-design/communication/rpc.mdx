# RPC

## Overview

Remote procedure calls (RPC) is a technique that allows a program to execute a function on another computer as if it were a local function.

It abstracts away the complexity of network communication.

RPC revolves more around actions and less around data/resources.


## How it works

### 1. **Interface Definition**
- A special **Interface Description Language (IDL)** is used to define:
  - The **API methods** (functions that can be called remotely)
  - The **data types** used in those methods
- This IDL acts like a **contract** between the client and server.

### 2. **Code Generation**
- The RPC framework uses the IDL to **auto-generate code**:
  - **Client Stub**: Code that runs on the client side
  - **Server Stub**: Code that runs on the server side
- These stubs handle the **communication logic**, so developers only focus on the business logic.

### 3. **Data Transfer Objects (DTOs)**
- Custom data types defined in the IDL are compiled into **classes or structs**.
- These are called **DTOs**, used to package and transfer data between client and server.

---

![](https://media.geeksforgeeks.org/wp-content/uploads/operating-system-remote-call-procedure-working.png)

### 4. **Client-Side Invocation**
- The client calls an RPC method.
- The **client stub**:
  - **Serializes** (encodes) the parameters (called **marshalling**)
  - Sends the request to the server

### 5. **Server-Side Execution**
- The **server stub**:
  - **Deserializes** (decodes) the incoming data
  - Invokes the actual method on the server
- After execution, the result is:
  - **Serialized** by the server stub
  - Sent back to the client

### 6. **Client Receives Response**
- The **client stub**:
  - **Deserializes** the response
  - Returns it to the caller as if it were a local function result


## Benefits

- **Easy to use** – Developers call remote methods like local ones.  
- **Hidden complexity** – Networking and data handling are fully abstracted.  
- **Consistent Error Handling** – Failures in the server result in an error or exception that can be handled like local method calls.
- **Strong typing** – Auto-generated stubs and DTOs reduce bugs.  
- **Faster development** – Less boilerplate, more focus on business logic.  


## Drawbacks

1. **Performance Issues**. Remote methods are slower than local ones because they involve network communication.
   - To avoid blocking the client’s execution, API designers should offer asynchronous versions of slow methods.
2. **Unreliable**. RPC involves communication over a network, which is **inherently unreliable**.
   - Best Practice: Use Idempotent Operations to safely retry without changing the result.
3. **Tighly coupled**. Any change requires regenerating client stubs. This can lead to lockstep releases.


## Considerations

RPC is a perfect choice for:
- API provided to a different company instead of an end user app/web page
- Communication between different components within a large system
- Abstracting away the network communication and focusing only on the actions the client wants to perform


## gRPC

gRPC is a high-performance, open-source framework developed by Google for RPC APIs.

gRPC uses Protocol Buffers (protobufs) for defining service interfaces and encoding/decoding messages.

gRPC use HTTP2 for transport, improve performance and lower latency.


### Benefits

1. Better performance compared to REST APIs (by using protobufs and HTTP2)
2. Supports authentication, including Transport Layer Security (TLS) and token-based authentication.
3. Supports for load balancing and health checking, which is essential for building resilient distributed systems.


### Protobufs

Protobufs is a mechanism for serializing structured data into binary format.

Protobufs is language-neutral and platform-neutral.

Messages are much smaller than JSON or XML.

Protocol Buffers ensures that the API contracts are strongly typed, reducing the likelihood of errors due to mismatched data types.

How it works:
1. You define API interface in a `.proto` file
2. Use the `protoc` compiler to generate client and server code in your chosen language
3. The generated code can be used to serialize and deserialize data.


### Considerations

gRPC is a good choice when:  
- **You have control over both client and server implementations**: Since gRPC requires client-side code to be compiled against the server’s schema, it works best in environments where you manage both sides.  
- **You need efficient, high-performance communication**: gRPC is optimized for low-latency and high-throughput scenarios, making it ideal for service-to-service communication in microservices architectures.  
- **Using synchronous request-response model**: While gRPC can work with reactive extensions, it’s primarily designed for structured request-response interactions.  
