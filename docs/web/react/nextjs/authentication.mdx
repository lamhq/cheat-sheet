# Authentication

## Login

Render Login page:

```ts title="login/page.tsx"
"use client";

import { useFormState } from "react-dom";
import login from "./action";

export default function Login() {
  const [state, formAction] = useFormState(login, { error: "" });

  return (
    <form action={formAction}>
      {state.error && <span style={{ color: 'red' }}>{state.error}</span>}
      <label>Email<input name="email" type="email" required /></label>
      <label>Password<input name="password" type="password" required /></label>
      <button type="submit">Login</button>
    </form>
  );
}
```

Define a server action for handling login. It will:
- sends form data to backend API and retrieve auth token
- return the auth token to the browser via http-only cookie, this ensures:
   - the token is not accessible via JavaScript, enhancing security
   - future requests from the browser will automatically include the auth token in cookie
- on failure, return error message to the form

```ts title="login/action.ts"
"use server";

import { jwtDecode } from "jwt-decode";
import { cookies } from "next/headers";
import { redirect } from "next/navigation";
import { API_URL } from "@/app/common/constants/api";
import { getErrorMessage } from "@/app/common/util/errors";
import { FormError } from "@/app/common/interfaces/form-error.interface";
import { AUTHENTICATION_COOKIE } from "../auth-cookie";

export default async function login(_prevState: FormError, formData: FormData) {
  const res = await fetch(`${API_URL}/auth/login`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(Object.fromEntries(formData)),
  });
  const parsedRes = await res.json();
  if (!res.ok) {
    return { error: getErrorMessage(parsedRes) };
  }
  setAuthCookie(res);
  redirect("/");
}

function setAuthCookie(response: Response) {
  const setCookieHeader = response.headers.get("Set-Cookie");
  if (setCookieHeader) {
    const token = setCookieHeader.split(";")[0].split("=")[1];
    cookies().set({
      name: AUTHENTICATION_COOKIE,
      value: token,
      secure: true,
      httpOnly: true,
      expires: new Date(jwtDecode(token).exp! * 1000),
    });
  }
};
```

## Authenticate requests

To include the auth token in requests from server components, include the cookies (sent from the client) in the request header when calling the `fetch` API.

```ts title="fetch-with-auth.ts"
import { cookies } from "next/headers";
import { API_URL } from "../constants/api";

export const get = async (path: string) => {
  const res = await fetch(`${API_URL}/${path}`, {
    headers: {
      Cookie: cookies().toString(),
    },
  });
  return res.json();
};

// export const post = ... (similar to get)
```

```ts title="profile/page.tsx"
import get from "@utils/fetch-with-auth.ts";

export default async function Profile() {
  const me = await get("users/me");
  console.log(me);
  return <></>;
}
```


## Protect routes

Define a server action that checks if the user is authenticated:
  
```ts title="authenticated.ts"
"use server";
import { cookies } from "next/headers";
import { AUTHENTICATION_COOKIE } from "./auth-cookie";

export default function authenticated() {
  return !!cookies().get(AUTHENTICATION_COOKIE)?.value;
}
```

Define a Next.js middleware that redirects unauthenticated users to the login page unless the requested path matches public routes.

```ts
import { NextRequest } from "next/server";
import authenticated from "./app/auth/authenticated";
import { unauthenticatedRoutes } from "./app/common/constants/routes";

export function middleware(request: NextRequest) {
  if (
    !authenticated() &&
    !unauthenticatedRoutes.some((route) =>
      request.nextUrl.pathname.startsWith(route.path)
    )
  ) {
    return Response.redirect(new URL("/auth/login", request.url));
  }
}

export const config = {
  matcher: ["/((?!api|_next/static|_next/image|.*\\.png$).*)"],
};
```


## Access auth state

Modify the application's provider component to accept an auth state via props and provides it to the rest of the app via React Context.

```ts title="provider.tsx"
"use client";

import { ReactElement } from "react";
import { AuthContext } from "./auth/auth-context";

interface ProviderProps {
  children: ReactElement[];
  authenticated: boolean;
}

export default function Providers({ children, authenticated }: ProviderProps) {
  return (
    <AuthContext.Provider value={authenticated}>
      {children}
    </AuthContext.Provider>
  );
}
```

Render the provider in the root layout, passing the auth state retrieved from cookies.

```ts title="layout.tsx"
import type { Metadata } from "next";
import Providers from "./providers";
import authenticated from "./auth/authenticated";

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const isAuthenticated = await authenticated();

  return (
    <html lang="en">
      <body>
        <Providers authenticated={isAuthenticated}>
          {children}
        </Providers>
      </body>
    </html>
  );
}
```

Access the auth state in client components:

```ts title="header.tsx"
"use client";

import { AuthContext } from "../auth/auth-context";
import { useContext } from "react";

interface HeaderProps {
  logout: () => Promise<void>;
}

export default function Header({ logout }: HeaderProps) {
  const isAuthenticated = useContext(AuthContext);

  if (!isAuthenticated) return null;

  return (
    <button onClick={logout}>Logout</button>
  );
}
```


## Authorization

Once authenticated, you can implement authorization to check if the user is authorized to access a route or perform an action within your application.

**On the client**:
1. Upon login, the API returns user roles or permissions to the client 
2. They are used for quick operations, such as showing/hiding UI elements or redirecting users based on permissions or roles.

**On the server**, use a middelware to perform authentication & authorization checks on every request. Avoid database checks to prevent performance issues.

> [!CAUTION]
> Be cautious when doing checks in [Layouts](https://nextjs.org/docs/app/guides/authentication#layouts-and-auth-checks) as these don't re-render on navigation, meaning the user session won't be checked on every route change.