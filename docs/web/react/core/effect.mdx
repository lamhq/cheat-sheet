# Effect

## Side Effects

Side effects are operations that affect something outside the scope of the component rendering process.

Examples:
- Starting an animation
- Changing the data
- Fetching data from an API
- Subscribing to a data stream or event
- Setting up timers or intervals
- Manually updating the DOM
- Logging or analytics
- Saving data to local storage

Side effects should go in event handlers (functions triggered by user actions, like clicking a button).

If no suitable handler exists, use `useEffect` to run the side effect after rendering, but it should be the last resort.


## How it work?

Effects are pieces of code that will be run by React in certain conditions.

- By default, Effects run after every render.
- Most Effects should only re-run when it's dependencies change.
- Some Effects need to specify how to clean up what they were doing.

You can tell React to **skip unnecessarily re-running the Effect** by specifying an array of dependencies as the second argument to the `useEffect` call.

```js
useEffect(() => {
  // This runs after every render
});

useEffect(() => {
  // This runs only on mount (when the component appears)
}, []);

useEffect(() => {
  // This runs on mount *and also* if either a or b have changed since the last render
}, [a, b]);
```

> [!NOTE]
> You will get a lint error if the dependencies you specified don't match what React expects based on the code inside your Effect.   
> If you don’t want some code to re-run, edit the Effect code itself to not “need” that dependency.


## Example: Video player

1. We have a `VideoPlayer` component that render the built-in browser `<video>` tag, it accept `src` and `isPlaying` props
2. When `isPlaying` prop change, we want to play/pause the video. But the `<video>` tag doesn't have a `isPlaying` prop
3. We synchronize the value of `isPlaying` prop to tells whether the video should be playing by getting a ref to the `<video>` DOM node, and then call its `play()` and `pause()` methods when `isPlaying` prop changes

```jsx
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  }, [isPlaying]);

  return <video ref={ref} src={src} loop playsInline />;
}
```


## Cleanup

React will call your cleanup function each time before the Effect runs again, and one final time when the component unmounts. 

```js
useEffect(() => {
  const connection = createConnection();
  connection.connect();
  return () => {
    connection.disconnect();
  };
}, []);
```


## Development mode

In development, React remounts every component once immediately after its initial mount (React intentionally unmounts and remounts it).

This ensure your effects and cleanup logic are correct. When you implement the cleanup well, there should be no user-visible difference between running the Effect once vs running it, cleaning it up, and running it again.

In this example, your code doesn’t close the connection when the component unmounts, so `"✅ Connecting..."` gets printed twice:

```jsx
import { useEffect } from 'react';

function createConnection() {
  // A real implementation would actually connect to the server
  return {
    connect() {
      console.log('✅ Connecting...');
    },
    disconnect() {
      console.log('❌ Disconnected.');
    }
  };
}

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}
```


## When to use Effects?

1. [Controlling non-React widgets](https://react.dev/learn/synchronizing-with-effects#controlling-non-react-widgets) (map, modal, video player, etc)
2. [Subscribing to events](https://react.dev/learn/synchronizing-with-effects#subscribing-to-events) (scroll, resize, etc)
3. [Triggering animations](https://react.dev/learn/synchronizing-with-effects#triggering-animations) (fade in, slide down, etc)
4. [Fetching data](https://react.dev/learn/synchronizing-with-effects#fetching-data) (API, database, etc)
5. [Sending analytics](https://react.dev/learn/synchronizing-with-effects#sending-analytics) (Google Analytics, Mixpanel, etc)


## When not to use Effects

If there is no external system involved, you shouldn’t need an Effect.

1. [Initializing the application](https://react.dev/learn/synchronizing-with-effects#not-an-effect-initializing-the-application). You can put it outside your components
2. [Handling user events](https://react.dev/learn/synchronizing-with-effects#not-an-effect-buying-a-product). This should go to event handlers
3. [Updating state based on props or state](https://react.dev/learn/you-might-not-need-an-effect#updating-state-based-on-props-or-state). Just calculate it during rendering.
