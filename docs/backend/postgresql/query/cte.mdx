# PostgreSQL CTE

A common table expression is a temporary result set which you can reference within another SQL statement including `SELECT`, `INSERT`, `UPDATE` or `DELETE`.

The CTEs are like temporary tables that exist only during the execution of the query.

Common Table Expressions or CTEs are typically used to simplify complex joins and subqueries in PostgreSQL.

The following shows the syntax of creating a CTE:

```sql
WITH cte_name (column_list) AS (
    CTE_query_definition 
)
statement;
```

```sql
WITH cte_film AS (
  SELECT 
    film_id, 
    title,
    (CASE 
      WHEN length < 30 THEN 'Short'
      WHEN length < 90 THEN 'Medium'
      ELSE 'Long'
    END) length    
  FROM
    film
)
SELECT
  film_id,
  title,
  length
FROM 
  cte_film
WHERE
  length = 'Long'
ORDER BY 
  title; 
```


## Joining a CTE with a table example

```sql
WITH cte_rental AS (
  SELECT staff_id,
    COUNT(rental_id) rental_count
  FROM rental
  GROUP BY staff_id
)
SELECT 
  s.staff_id,
  first_name,
  last_name,
  rental_count
FROM staff s
INNER JOIN cte_rental USING (staff_id); 
```


## Recursive query

A recursive query is a query that refers to a recursive CTE. 

The recursive queries are useful in many situations such as querying hierarchical data like organizational structure, bill of materials, etc.

The following illustrates the syntax of a recursive CTE:

```sql
WITH RECURSIVE cte_name AS(
    CTE_query_definition -- non-recursive term
    UNION [ALL]
    CTE_query definion  -- recursive term
) SELECT * FROM cte_name;
```

A recursive CTE has three elements:

- Non-recursive term: the non-recursive term is a CTE query definition that forms the base result set of the CTE structure.
- Recursive term: the recursive term is one or more CTE query definitions joined with the non-recursive term using the UNION or UNION ALL operator. The recursive term references the CTE name itself.
- Termination check: the recursion stops when no rows are returned from the previous iteration.


Example:

```sql
CREATE TABLE employees (
	employee_id serial PRIMARY KEY,
	full_name VARCHAR NOT NULL,
	manager_id INT
);
```

```sql
INSERT INTO employees (
	employee_id,
	full_name,
	manager_id
)
VALUES
	(1, 'Michael North', NULL),
	(2, 'Megan Berry', 1),
	(3, 'Sarah Berry', 1),
	(4, 'Zoe Black', 1),
	(5, 'Tim James', 1),
	(6, 'Bella Tucker', 2),
	(7, 'Ryan Metcalfe', 2),
	(8, 'Max Mills', 2),
	(9, 'Benjamin Glover', 2),
	(10, 'Carolyn Henderson', 3),
	(11, 'Nicola Kelly', 3),
	(12, 'Alexandra Climo', 3),
	(13, 'Dominic King', 3),
	(14, 'Leonard Gray', 4),
	(15, 'Eric Rampling', 4),
	(16, 'Piers Paige', 7),
	(17, 'Ryan Henderson', 7),
	(18, 'Frank Tucker', 8),
	(19, 'Nathan Ferguson', 8),
	(20, 'Kevin Rampling', 8);
```

The following query returns all subordinates of the manager with the id `2`:

```sql
WITH RECURSIVE subordinates AS (
	SELECT
		employee_id,
		manager_id,
		full_name
	FROM
		employees
	WHERE
		employee_id = 2
	UNION
		SELECT
			e.employee_id,
			e.manager_id,
			e.full_name
		FROM
			employees e
		INNER JOIN subordinates s ON s.employee_id = e.manager_id
) SELECT
	*
FROM
	subordinates;
```

**How it works:**

The non-recursive term returns the base result set R0 that is the employee with the id 2.

| employee_id | manager_id |  full_name |
-------------|------------|-------------
|2           |          1 | Megan Berry |

The first iteration of the recursive term returns the following result set:

| employee_id | manager_id |    full_name |
|-------------|------------|-----------------|
|           6 |          2 | Bella Tucker|
|           7 |          2 | Ryan Metcalfe |
|           8 |          2 | Max Mills |
|           9 |          2 | Benjamin Glover |

The second iteration of the recursive member uses the result set above step as the input value, and returns this result set:

| employee_id | manager_id |    full_name |
|-------------|------------|-----------------|
|          16 |          7 | Piers Paige |
|          17 |          7 | Ryan Henderson|
|          18 |          8 | Frank Tucker|
|          19 |          8 | Nathan Ferguson |
|          20 |          8 | Kevin Rampling |

The third iteration returns an empty result set

PostgreSQL returns the final result set that is the union of all result sets in the first and second iterations generated by the non-recursive and recursive terms.

| employee_id | manager_id |    full_name |
|------------- |------------ |----------------- |
|           2 |          1 | Megan Berry |
|           6 |          2 | Bella Tucker |
|           7 |          2 | Ryan Metcalfe |
|           8 |          2 | Max Mills |
|           9 |          2 | Benjamin Glover |
|          16 |          7 | Piers Paige |
|          17 |          7 | Ryan Henderson |
|          18 |          8 | Frank Tucker |
|          19 |          8 | Nathan Ferguson |
|          20 |          8 | Kevin Rampling |


## Examples

```sql
DROP TABLE orders;

CREATE TABLE orders (
	order_id serial PRIMARY KEY,
	product_id INT NOT NULL,
	product_name VARCHAR (255) NOT NULL,
	price DECIMAL (11, 2),
	group_id INT NOT NULL,
	qty INT NOT NULL,
  order_date DATE,
  total INT NOT NULL,
	FOREIGN KEY (group_id) REFERENCES product_groups (group_id)
);

INSERT INTO orders (product_id, product_name, group_id,price,qty,order_date,total)
VALUES
	(1, 'Microsoft Lumia', 1, 200, 10, '2022-09-24', 100),
	(1, 'Microsoft Lumia', 1, 400, 30, '2022-09-24', 150),
	(2, 'Nexus', 1, 500, 12, '2022-09-23', 300),
	(2, 'Nexus', 1, 900, 110, '2022-09-23', 10),
	(2, 'Nexus', 2, 1200, 6, '2022-09-23', 200),
	(3, 'Lenovo Thinkpad', 2, 700, 10, '2022-09-22', 10),
	(3, 'Lenovo Thinkpad', 2, 700, 30, '2022-09-22', 20),
	(3, 'Lenovo Thinkpad', 2, 800, 5, '2022-09-22', 45),
	(3, 'Lenovo Thinkpad',  3, 700, 20, '2022-09-22', 10),
	(4, 'Kindle Fire', 3, 150, 10, '2022-09-21', 10),
	(4, 'Kindle Fire', 3, 200, 60, '2022-09-22', 50);
```

### Get order count of each day of each product

```sql
SELECT product_id, order_date, count(order_id) 
FROM orders 
GROUP BY product_id, order_date;
```

### Get average daily order count of each product

```sql
WITH daily_order_count AS (
  SELECT product_id, order_date, count(order_id) cnt
  FROM orders 
  GROUP BY product_id, order_date
),
avg_order_count AS (SELECT product_id, AVG(cnt) avgcnt
  FROM daily_order_count
  GROUP BY product_id
)
SELECT product_id, 
  (SELECT (CASE 
      WHEN avgcnt > 20 THEN 'Short Tail'
      WHEN avgcnt >=10 AND avgcnt <= 20 THEN 'Mid Tail'
      WHEN avgcnt < 10 THEN 'Long Tail'
    END) 
  FROM avg_order_count 
  WHERE avg_order_count.product_id=orders.product_id)
FROM orders
GROUP BY product_id;

SELECT ROW_NUMBER() OVER (), sum(qty) AS "Total Qty Sold"
FROM orders
GROUP BY product_id
ORDER BY "Total Qty Sold" DESC;
```

### GET `Rank`

```sql
WITH daily_order_count AS (
  SELECT product_id, order_date, count(order_id) cnt
  FROM orders 
  GROUP BY product_id, order_date
),
avg_order_count AS (SELECT product_id, AVG(cnt) avgcnt
  FROM daily_order_count
  GROUP BY product_id
)
SELECT 
  ROW_NUMBER() OVER () AS "Rank",
  product_id AS "Product ID",
  product_name AS "Item Name",
  l1_cat AS "Category",
  (SELECT (CASE 
      WHEN avgcnt > 20 THEN 'Short Tail'
      WHEN avgcnt >=10 AND avgcnt <= 20 THEN 'Mid Tail'
      WHEN avgcnt < 10 THEN 'Long Tail'
    END) 
  FROM avg_order_count 
  WHERE avg_order_count.product_id=orders.product_id) AS "Tier",
  MIN(price) AS "Min. Selling Price",
  SUM(qty_sold) AS "Total Qty Sold",
  SUM(gmv) AS "Total GMV",
  COUNT(order_id) AS "Total Orders"
FROM my_order_trans
WHERE order_date BETWEEN ('2022-09-01', '2022-09-30')
GROUP BY product_id
ORDER BY "Total Qty Sold" DESC
LIMIT 10;