# Closure

## Introduction

Closure allow code inside a function has access to any variables defined in the outer scope, even when the outer function has finished executing.

```ts
function outerFunction(arg) {
  var variableInOuterFunction = arg;

  function bar() {
    console.log(variableInOuterFunction); // Access a variable from the outer scope
  }

  // Call the local function to demonstrate that it has access to arg
  bar();
}

outerFunction("hello closure"); // logs hello closure!
```


## Why it's awesome

- Encapsulation: Closures can be used to create private variables and methods.
  ```ts
  function createCounter() {
    let val = 0;
    return {
      increment() { val++ },
      getVal() { return val }
    }
  }

  let counter = createCounter();
  counter.increment();
  console.log(counter.getVal()); // 1
  counter.increment();
  console.log(counter.getVal()); // 2
  ```
- Data hiding: Closures can be used to hide implementation details.
- Partial application: Closures can be used to create new functions with pre-set arguments.
- Memoization: Closures can be used to cache the results of expensive function calls.
