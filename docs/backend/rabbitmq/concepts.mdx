# Concepts

## Message Routing Flow

![](https://www.cloudamqp.com/img/blog/exchanges-bidings-routing-keys.png)

1. Producer sends message with routing key (e.g., "cat" or "dog")
2. Exchange accepts message and compares routing key with existing bindings
3. If matching binding exists → message persisted in bound queue
4. If no matching binding → publisher receives an error
5. Once persisted, RabbitMQ tries to deliver to consumers ASAP

> [!WARNING]
> The step numbers in the image do not exactly correspond to the sequential flow described above.

## Exchange

Producer never publishes messages directly to the queue, it must use an **Exchange**.

Exchange is bound to queue by **Binding Key**. Exchange compares **Routing Key** (from producer) with **Binding Key** to determine the destination queue.

### Exchange Types

- **Nameless/Default**: compares routing key with queue name; allows sending messages "directly" to queue. It is a special built-in **Direct Exchange** created by RabbitMQ.
- **Fanout**: Routes message to ALL bound queues; ignores routing key
- **Direct**: Routes to queue that matches routing key exactly
- **Topic**: Routes to queues where binding key pattern matches routing key (e.g., binding key: `*.logs.error` matches routing key: `app1.logs.error`)
- **Headers**: Same as Topic, but compares binding key against message headers


## Queue

Queue is an **ordered collection** of messages.

Queue is located on the node where it was declared and is referenced by unique name. Name can be provided or auto-generated by RabbitMQ

One queue is a one Erlang process.

When node starts, up to **16,384 messages** are loaded into RAM from the queue (can be changed via policies or configuration parameters).

Queues prefixed with `amq` are reserved for RabbitMQ internal purposes only.

### Queue Properties

Mandatory Properties:

- **Name**: Human-readable name (use good naming convention, avoid "test1", "test2")
- **Durability**: Durable queues survive broker restart; non-durable queues are empty after restart
- **Auto Delete**: Queue automatically deleted when all consumers disconnect
- **Classic or Quorum**:
  - Quorum queues: new standard, highly available by default (recommended)
  - Classic queues: need special mirroring policy to be high availability
- **Exclusive**: Used by one connection only; auto-deleted when connection closes

Optional Properties:

- **Priority**: Enable sorting messages by priority (message attribute); no guarantee of exact order
- **TTL**: Auto-removes unconsumed messages after specified time
- **Lazy queues**, **Dead letter queues**, and more


## Message Order

Queues are FIFO manner **in terms of producer** (messages are always held in the queue in publication order), but not in terms of consumer.

Consuming order is guaranteed when:
- messages published in one channel
- passing through one exchange
- stored in one queue
- consumed by exactly one outgoing channel


## Message Consumption

Consumer can **accept or reject** messages. If rejected with `requeue=true`, message goes back to queue (order NOT guaranteed).
